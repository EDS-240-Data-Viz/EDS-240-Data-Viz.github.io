---
output: html_document
editor_options: 
  chunk_output_type: console
---

### ----------------- Wrangle the data -----------------

```{r}
#| eval: true
#| echo: false
##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
##                              important links                             ----
##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# State-level precipitation by year/month: <https://www.ncei.noaa.gov/access/monitoring/climate-at-a-glance/statewide/mapping>
# County-level precipitation by year/month: <https://www.ncei.noaa.gov/access/monitoring/climate-at-a-glance/county/mapping/110/pcp/202310/1/value> and remove first few rows manually
# Tutorial: <https://eriqande.github.io/rep-res-web/lectures/making-maps-with-R.html>

##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
##                                    setup                                 ----
##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#..........................load packages.........................
library(tidyverse)
library(maps) 

#.........................get shape data.........................
states <- map_data("state")
counties <- map_data("county")

#....................import precipitation data...................
precip_counties <- read_csv(here::here("slides", "data", "county-precip-oct2023.csv"), skip = 4) |> 
  janitor::clean_names()

##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
##                               data wrangling                             ----
##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#..............update names of counties df variables.............
us_counties <- counties |> 
  
  # select / rename cols of interest ----
  select(state = region, county = subregion, long, lat, group, order) |> 
  
  # make all county & state names Title Case ----
  mutate(county = str_to_title(county),
         state = str_to_title(state)) |> 
  
  # fix different spellings so that they match county names in precip data ----
  mutate(county = case_when(
    county == "De Kalb" ~ "DeKalb",
    county == "De Soto" ~ "DeSoto", # works for FL & MI
    county == "Du Page" ~ "DuPage",
    county == "La Porte" ~ "LaPorte",
    county == "Obrien" ~ "O'Brien",
    county == "Prince Georges" ~ "Prince George's",
    county == "Queen Annes" ~ "Queen Anne's",
    county == "Ste Genevieve" ~ "Ste. Genevieve",
    county == "La Moure" ~ "LaMoure",
    state == "Texas" & county == "De Witt" ~ "DeWitt",
    # county == "St. Marys" ~ "St. Mary's", # isn't working??
    TRUE ~ county
    )) |> 
  mutate(county = str_replace(string = county, pattern = "St ", replacement = "St. ")) |> 
  
  # remove DC & Yellowstone National Park ----
  filter(!state %in% c("District Of Columbia")) |> 
  filter(!county %in% c("Yellowstone National"))


#..........clean precip data & make sure var names match.........
precip_counties_wrangled <- precip_counties |> 
  
  # more intuitive col name ----
  rename(county = name) |> 
  
  # make all county & state names lower case ----
  mutate(county = str_to_lower(county),
         state = str_to_lower(state)) |>
  
  # remove recurring patterns ----
  mutate(county = str_remove(county, pattern = " county")) |> # across all county names
  mutate(county = str_remove(county, pattern = " parish")) |> # LA
  
  # make state & county names Title Case again ----
  mutate(county = str_to_title(county),
         state = str_to_title(state)) |> 
  
  # fix different spellings so that they match county names in precip data ----
  mutate(county = case_when(
    county == "Dekalb" ~ "DeKalb",
    county == "Desoto" ~ "DeSoto", # works for FL & MI
    state == "Louisiana" & county == "De Soto" ~ "DeSoto",
    county == "Dupage" ~ "DuPage",
    county == "Lasalle" ~ "La Salle",
    county == "Laporte" ~ "LaPorte",
    county == "O'brien" ~ "O'Brien",
    county == "Lamoure" ~ "LaMoure",
    state == "Texas" & county == "Dewitt" ~ "DeWitt",
    county == "St. Mary's" ~ "St. Marys",
    county == "Suffolk City" ~ "Suffolk",
    county == "Hampton City" ~ "Hampton",
    county == "Virginia Beach City" ~ "Virginia Beach",
    county == "Newport News City" ~ "Newport News",
    county == "Norfolk City" ~ "Norfolk",
    TRUE ~ county
  )) |> 
  
  # remove DC & other non-counties
  filter(!county %in% c("Washington, D.c.", "Alexandria City", "Bristol City")) |>
  
  # select & rename cols ----
  select(state, county, precip = value, mean_1901_2000 = x1901_2000_mean, anomaly = anomaly_1901_2000_base_period) |> 
  
  # coerce precip from chr to numeric ----
  mutate(precip = as.numeric(precip))

##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
##  ~ used for identifying which county names to edit  ----
##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# unique_us_counties <- us_counties |> 
#   distinct(state, county)
# 
# unique_precip_counties <- precip_counties_wrangled |> 
#   distinct(state, county)
# 
# missing_from_us_counties <- anti_join(unique_precip_counties, unique_us_counties) |> 
#   rename(county_in_us = county)
# missing_from_precip_counties <- anti_join(unique_us_counties, unique_precip_counties) |> 
#   rename(county_in_precip = county)

##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
##  ~ -----------------------------------------------  ----
##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#............................join dfs............................
joined_precip_us_counties <- full_join(precip_counties_wrangled, us_counties)
```


## ----------------- Create base map -----------------

```{r}

# 'group' controls whether adjacent points are connected by lines (each county is a "group," therefore points are connected) ----
base_map <- ggplot(data = states, mapping = aes(x = long, y = lat, group = group)) + 
  
  # plot precip values by county; geom_polygon() drawn lines between points and “closes them up” (i.e. draws a line from the last point back to the first point) ----
  geom_polygon(data = joined_precip_us_counties, aes(fill = precip)) + 
  
  # darken state lines ----
  geom_polygon(color = "#2F2D2C", fill = NA, linewidth = 0.1) +
  
  # to fix the relationship between one unit in the y direction and one unit in the x direction; may need different values for different regions depending on where they are on the globe (e.g. close to the poles)
  #coord_fixed(1.3) +
  
  # update labels ----
  labs(title = "Total Precipitation, by County",
       subtitle = "October 2023") +
  
  # set theme to clean up appearance ----
  theme_void() + 
  
  # theme adjustments ----
  theme(
    legend.position = "bottom"
  )
  
base_map
```

## ----------------- Add projection -----------------

```{r}
base_map_proj <- base_map + 
  coord_map(projection = "mercator")

base_map_proj
```

## ----------------- Custom function to add correct guide bar styling -----------------

```{r}
# apply to following maps to customize legend appearance ----
custom_guide <- function(type) {
  
  # if gradient, use guide_color()
  if (type == "g") {
    guides(fill = guide_colorbar(title = "Precipitation (inches)",
                                 title.position = "top",
                                 barwidth = 15, barheight = 1))
    
  # if bin, use guide_colorsteps()
  } else if (type == "b") {
    guides(fill = guide_colorsteps(title = "Precipitation (inches)",
                                   title.position = "top",
                                   barwidth = 15, barheight = 1))
  }
}
```

## ----------------- Initial attempt: manually create binned color gradient -----------------

```{r}
# # plot (viridis) ----
# base_map_proj + 
#   scale_fill_viridis_c() +
#   custom_guide(type = "g")

# define palette ----
my_palette <- c("#543006", "#975F1C", "#AC7E42", "#C09C66", "#D6BB8C", "#EBD9B0","#D5D4CE",
                 "#B2DDD7", "#8BC2BC", "#64A7A1", "#3B8E86", "#16726B", "#003C30")

# plot (gradient) ----
base_map_proj + 
  scale_fill_gradientn(colors = my_palette) +
  custom_guide(type = "g")

# plot (binned) ----
base_map_proj + 
  scale_fill_stepsn(colors = my_palette) +
  custom_guide(type = "b")
```

We have a map (yay!) but the binned version is not so helpful yet. We're not seeing much detail (most of the country is colored brown, having received 0-5"). ggplot is also defaulting to 5 bins (colors), which is not what we want. We'll have to define our own bins. One approach is to calculate & specify equal bin sizes:

1. get max & min precipitations
2. subtract them
3. divide the result by the number of intervals that we want (11 colors, ideally)

```{r}
# range of data ----
range(na.omit(joined_precip_us_counties)$precip) # 0.0-10.2 

# calculate bin size ----
(max(na.omit(joined_precip_us_counties)$precip) - min(na.omit(joined_precip_us_counties)$precip))/11 # 0.93
```

Using this approach, class size would be 1 (rounded from 0.93). To achieve that, we need to set breaks that are a width of 1 from our min value (0) to our max (11, since max value is 10.2). We also need the appropriate amount of colors to fill those bins.

```{r}
# define palette ----
my_palette <- c("#543006", "#975F1C", "#C09C66", "#D6BB8C", "#EBD9B0","#E8E8E8",
                 "#B2DDD7", "#8BC2BC", "#64A7A1", "#16726B", "#003C30") 

# define breaks ----
my_breaks <- c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)

# plot ----
base_map_proj + 
  scale_fill_stepsn(colors = my_palette,
                    breaks = my_breaks,
                    values = scales::rescale(my_breaks)) +
  custom_guide(type = "b") 
  





# base_map_proj + 
#   scale_fill_stepsn(colors = my_palette,
#                     breaks = my_breaks, 
#                     values = scales::rescale(my_breaks)) +
#   custom_guide(type = "b")
# 
# 
# scale_fill_stepsn(name = "", 
#                     colors =c("#2171b5", "#6baed6", "#bdd7e7", "#fcae91", "#fb6a4a", "#cb181d"),
#                     breaks = c(-25, -10, 0, 10, 50),
#                     values = scales::rescale(c(-25, -10, 0, 10, 25, 50))) 


```

Attempt B is a better, though it would be wise to look at the distribution of our precipitation data to see if we might be losing any important details:

```{r}
# plot histogram ----
ggplot(joined_precip_us_counties, aes(x = precip)) +
  geom_histogram()

# calculate median ----
median(na.omit(joined_precip_us_counties)$precip) # 2.02
```

Our data are heavily right-skewed (most are smaller values), and our median value is 2.02" -- meaning half our our data fall below 2.02". This means that we're likely losing details at the lower end of the spectrum, since we have so many small precipitation totals. Let's take an even closer look by calculating some quantiles:

```{r}
# default quartiles ----
quantile(joined_precip_us_counties$precip,
         probs = seq(from = 0, to = 1, by = 0.25),
         na.rm = TRUE)
```

How do we interpret this?

- Our min value is 0 and max value is 10.20. 
- 25% of our precipitation recordings live below 1.19"
- 50% of our precipitation recordings live below 2.02"
- 75% of our precipitation recordings live below 3.31"
- 100% of our precipitation recordings live below 10.20"

We can adjust the quantiles calculated:

```{r}
quantile(joined_precip_us_counties$precip, 
         probs = seq(from = 0, to = 1, by = 0.10),
         na.rm = TRUE)
```

We see here that 10% of all our precipitation recordings live below 0.65"! And 90% live below 4.47".

```{r}
# define palette ----
# define palette ----
my_palette <- c("#543006", "#975F1C", "#C09C66", "#D6BB8C", "#EBD9B0","#E8E8E8",
                 "#B2DDD7", "#8BC2BC", "#64A7A1", "#16726B", "#003C30") 
# my_palette <- c("#543006", "#975F1C", "#AC7E42", "#C09C66", "#D6BB8C", "#EBD9B0","#E8E8E8",
#                  "#B2DDD7", "#8BC2BC", "#64A7A1", "#3B8E86", "#16726B", "#003C30")

# define breaks ----
my_breaks = c(0, 0.65, 1.05, 1.35, 1.61, 2.02, 2.51, 3.05, 3.61, 4.47, 10.20)

# plot ----
base_map +
  scale_fill_stepsn(trans = scales::pseudo_log_trans(),
                    colors = my_palette,
                    breaks = my_breaks) +
  custom_guide(type = "b")
  
```
























<!-- Next, we can try another method, which is based on the mean & standard deviation (not sure that this makes sense though, since we don't have normally distributed data). -->


<!-- ## ----------------- Attempt C: manually calculate & specify bins based on mean & sd ----------------- -->

<!-- First, calculate the mean & standard deviation: -->

```{r}
# mean(na.omit(joined_precip_us_counties$precip)) # 2.4
# sd(na.omit(joined_precip_us_counties$precip)) # 1.6
```

<!-- Then, plot with breaks calculated as X number of standard deviations away from the mean: -->

```{r}
# # define palette ----
# my_palette <- c("#543006", "#AC7E42", "#C09C66", "#E8E8E8",
#                 "#64A7A1", "#3B8E86", "#003C30")
# 
# # define breaks ----
# my_breaks <- c(0, 0.8, 2.4, 4, 5.6, 7.2, 8.8, 10.4)
# 
# # plot ----
# base_map_proj + 
#   scale_fill_stepsn(colors = my_palette,
#                     breaks = my_breaks) +
#   custom_guide(type = "b")
```

<!-- That doesn't help us so much still. Another option is to log-transform our color scale.  -->

```{r}
# # define palette ----
# my_palette <- c("#543006", "#975F1C", "#AC7E42", "#C09C66", "#D6BB8C", "#EBD9B0","#E8E8E8",
#                  "#B2DDD7", "#8BC2BC", "#64A7A1", "#3B8E86", "#16726B", "#003C30")
# 
# # define breaks ----
# my_breaks = c(0, 0.1, 0.5, 1, 2, 4, 6, 8, 10, 12, 15, 20, 25)
# 
# # plot ----
# base_map +
#     scale_fill_stepsn(trans = "log",
#                       colors = my_palette,
#                       breaks = my_breaks) 
  
```









```{r}
#| eval: true
#| echo: true
#| fig-align: "center"
#| out-width: "100%"
#| output-location: column

# # 'group' controls whether adjacent points are connected by lines (each county is a "group," therefore points are connected) ----
# method3 <- ggplot(data = states, mapping = aes(x = long, y = lat, group = group)) + 
#   
#   # plot precip values by county; geom_polygon() drawn lines between points and “closes them up” (i.e. draws a line from the last point back to the first point) ----
#   geom_polygon(data = joined_precip_us_counties, aes(fill = precip)) + 
#   
#   # darken state lines ----
#   geom_polygon(color = "#2F2D2C", fill = NA, linewidth = 0.1) +
#   
#   # to fix the relationship between one unit in the y direction and one unit in the x direction; may need different values for different regions depending on where they are on the globe (e.g. close to the poles)
#   coord_fixed(1.3) +
#   
#   # # OPTION 1: update colors with pre-fab palette ----
#   # scale_fill_viridis_c(option = "D") +
#   # scale_fill_distiller(palette = 'Purples')
#   # scale_fill_viridis_c(trans = "log", breaks=c(0.1, 0.5, 2,4,6, 8, 10, 12, 15, 20, 25), 
#   #                  name="Number of restaurant", 
#   #                  guide = guide_legend( 
#   #                                        label.position = "bottom", 
#   #                                        title.position = 'top',
#   #                                        nrow=1))
#   # 
#   # OPTION 2: manually create a color gradient ----
#   # scale_fill_gradient(low = "#C8ECE6", high = "#213943") +
#   
#   # OPTION 2: manually create a color gradient ----
#   #scale_fill_gradient2(low = "#77A8B9", mid = "#FFFFFF", high = "#213943") +
#   scale_fill_steps2(#trans = "log",
#                     low = "#543006", mid = "#E8E8E8", high = "#003C30",
#                     midpoint = 4) +
#                     # colors = c("#543006", "#975F1C", "#AC7E42", "#C09C66", "#D6BB8C", "#EBD9B0",  
#                     #            "#E8E8E8", 
#                     #            "#B2DDD7", "#8BC2BC", "#64A7A1", "#3B8E86", "#16726B", "#003C30"), 
#                     # breaks = c(0, 0.1, 0.5, 1, 2, 4, 6, 8, 10, 12, 15, 20, 25)) +
#   
#   # update legend ----
#   guides(fill = guide_coloursteps(title = "Precipitation (inches)", 
#                                   title.position = "top",
#                                   barwidth = 25, barheight = 1)) +
#   
#   # update labels ----
#   labs(title = "Total Precipitation, by County",
#        subtitle = "January 2023") +
#   
#   # set theme to clean up appearance ----
#   theme_void() + 
#   
#   # theme adjustments ----
#   theme(
#     legend.position = "bottom"
#   )
# 
# method3
```
















```{r}
# # 'group' controls whether adjacent points are connected by lines (each county is a "group," therefore points are connected) ----
# original <- ggplot(data = states, mapping = aes(x = long, y = lat, group = group)) + 
#   
#   # plot precip values by county; geom_polygon() drawn lines between points and “closes them up” (i.e. draws a line from the last point back to the first point) ----
#   geom_polygon(data = joined_precip_us_counties, aes(fill = precip)) + 
#   
#   # darken state lines ----
#   geom_polygon(color = "#2F2D2C", fill = NA, linewidth = 0.1) +
#   
#   # to fix the relationship between one unit in the y direction and one unit in the x direction; may need different values for different regions depending on where they are on the globe (e.g. close to the poles)
#   coord_fixed(1.3) +
#   
#   # manually create a binned color gradient; nice.breaks = TRUE by default ----
#   scale_fill_stepsn(colors = c("#543006", "#975F1C", "#AC7E42", "#C09C66", "#EBD9B0",
#                                "#E8E8E8", "#B2DDD7", "#8BC2BC", "#3B8E86", "#16726B", "#003C30")) +
#                     #breaks = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19)) +
# 
# 
#   # update legend ----
#   # guides(fill = guide_colourbar(title = "Precipitation (inches)",
#   #                               title.position = "top",
#   #                               barwidth = 15, barheight = 1)) +
#   
#   # update labels ----
#   labs(title = "Total Precipitation, by County",
#        subtitle = "January 2023") +
#   
#   # set theme to clean up appearance ----
#   theme_void() + 
#   
#   # theme adjustments ----
#   theme(
#     legend.position = "bottom"
#   )
#   
# original
```


```{r}
#| eval: false
#| echo: true
#| fig-align: "center"
#| out-width: "100%"
#| output-location: column

# # 'group' controls whether adjacent points are connected by lines (each county is a "group," therefore points are connected) ----
# method1 <- ggplot(data = states, mapping = aes(x = long, y = lat, group = group)) + 
#   
#   # plot precip values by county; geom_polygon() drawn lines between points and “closes them up” (i.e. draws a line from the last point back to the first point) ----
#   geom_polygon(data = joined_precip_us_counties, aes(fill = precip)) + 
#   
#   # darken state lines ----
#   geom_polygon(color = "#2F2D2C", fill = NA, linewidth = 0.1) +
#   
#   # to fix the relationship between one unit in the y direction and one unit in the x direction; may need different values for different regions depending on where they are on the globe (e.g. close to the poles)
#   coord_fixed(1.3) +
#   
#   # manually create a binned color gradient ----
#   scale_fill_stepsn(colors = c("#543006", "#975F1C", "#AC7E42", "#C09C66", "#D6BB8C", "#EBD9B0",  
#                                "#E8E8E8", 
#                                "#B2DDD7", "#8BC2BC", "#64A7A1", "#3B8E86", "#16726B", "#003C30"),
#                     breaks = c(0, 1.7, 3.4, 5.1, 6.8, 8.5, 10.2, 11.9, 13.6, 15.3, 17, 18.7)) +
#                    
# 
#   # update legend ----
#   guides(fill = guide_colourbar(title = "Precipitation (inches)",
#                                 title.position = "top",
#                                 barwidth = 25, barheight = 1)) +
#   
#   # update labels ----
#   labs(title = "Total Precipitation, by County",
#        subtitle = "January 2023") +
#   
#   # set theme to clean up appearance ----
#   theme_void() + 
#   
#   # theme adjustments ----
#   theme(
#     legend.position = "bottom"
#   )
#   
# method1
```


```{r}
#| eval: false
#| echo: true
#| fig-align: "center"
#| out-width: "100%"
#| output-location: column

# # 'group' controls whether adjacent points are connected by lines (each county is a "group," therefore points are connected) ----
# method2 <- ggplot(data = states, mapping = aes(x = long, y = lat, group = group)) + 
#   
#   # plot precip values by county; geom_polygon() drawn lines between points and “closes them up” (i.e. draws a line from the last point back to the first point) ----
#   geom_polygon(data = joined_precip_us_counties, aes(fill = precip)) + 
#   
#   # darken state lines ----
#   geom_polygon(color = "#2F2D2C", fill = NA, linewidth = 0.1) +
#   
#   # to fix the relationship between one unit in the y direction and one unit in the x direction; may need different values for different regions depending on where they are on the globe (e.g. close to the poles)
#   coord_fixed(1.3) +
#   
#   # manually create a binned color gradient ----
#   scale_fill_stepsn(colors = c("#543006", "#975F1C", "#AC7E42", "#C09C66", "#D6BB8C", "#EBD9B0",  
#                                "#E8E8E8", 
#                                "#B2DDD7", "#8BC2BC", "#64A7A1", "#3B8E86", "#16726B", "#003C30"),
#                     breaks = c(0, 1, 4, 7, 10, 13, 16, 19)) +
#                    
# 
#   # update legend ----
#   guides(fill = guide_colourbar(title = "Precipitation (inches)",
#                                 title.position = "top",
#                                 barwidth = 25, barheight = 1)) +
#   
#   # update labels ----
#   labs(title = "Total Precipitation, by County",
#        subtitle = "January 2023") +
#   
#   # set theme to clean up appearance ----
#   theme_void() + 
#   
#   # theme adjustments ----
#   theme(
#     legend.position = "bottom"
#   )
#   
# method2
```





```{r}
  # # OPTION 2: manually create a color gradient ----
  # #scale_fill_gradient2(low = "#77A8B9", mid = "#FFFFFF", high = "#213943") +
  # scale_fill_stepsn(trans = "log",
  #                   colors = c("#543006", "#975F1C", "#AC7E42", "#C09C66", "#EBD9B0", "#B2DDD7", "#8BC2BC", "#3B8E86", "#16726B", "#003C30"), 
  #                   breaks = c(0, 0.1, 0.5, 1, 2, 4, 6, 8, 10, 12, 15, 20, 25)) +
  # 
  # # update legend ----
  # guides(fill = guide_coloursteps(title = "Precipitation (inches)", 
  #                                 title.position = "top",
  #                                 barwidth = 15, barheight = 1)) +
  # 
  # # update labels ----
  # labs(title = "Total Precipitation, by County",
  #      subtitle = "January 2023") +
  # 
  # # set theme to clean up appearance ----
  # theme_void() + 
  # 
  # # theme adjustments ----
  # theme(
  #   legend.position = "bottom"
  # )
```











## ----------------- Data wrangling 2 ({usmap}) -----------------

```{r}
# ##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ##                                    setup                                 ----
# ##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# #..........................load packages.........................
# library(tidyverse)
# library(usmap)
# 
# #.........................get shape data.........................
# county_map <- us_map(regions = "counties") |> 
#   rename(state_abb = abbr, state_name = full)
# 
# #....................import precipitation data...................
# precip_counties <- read_csv(here::here("slides", "data", "county-precip-oct2023.csv"), skip = 4) |> 
#   janitor::clean_names() |> 
#   rename(county = name, state_name = state, precip_in = value) |> 
#   mutate(precip_in = as.numeric(precip_in))
# 
# ##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ##                                  join dfs                                ----
# ##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# precip_counties_wrangled <- full_join(precip_counties, county_map)

```

```{r}
# # empty map ----
# plot_usmap(regions = c(p),
#            exclude = c("AK", "HI"))
# 
# # fill counties ----
# precip_counties_wrangled |> 
#   select(fips, precip_in) |> 
#   plot_usmap(regions = "counties", exclude = c("AK", "HI"),
#              data = precip_counties_wrangled, values = "precip_in") + 
#   scale_fill_viridis_c() +
#   theme(legend.position = "bottom")
```













