---
format: 
  revealjs:
    slide-number: true
    # code-link: true
    highlight-style: a11y
    chalkboard: true
    theme: 
      - ../../meds-slides-styles.scss
editor_options: 
  chunk_output_type: console
---

## {#title-slide data-menu-title="Title Slide" background="#053660"} 

[EDS 240: Lecture 3.2]{.custom-title}

[*Visualizing amounts / rankings*]{.custom-subtitle}

<hr class="hr-teal">

[Week 3 | January 21^st^, 2026]{.custom-subtitle3}

---

## {#data-ranking data-menu-title="Data amounts / rankings"} 

[Visualizing data *amounts / rankings*?]{.slide-title}

<hr>

<br>
<br>

[Showing the relationship between a **numeric and categorical variable(s)**, i.e. comparing categorical groups based on their numeric values.]{.body-text-m}

<br>

```{r example-bar}
#| eval: true
#| echo: false
#| fig-align: "center"
library(tidyverse)

data <- tribble(
  ~group, ~value,
  "A", 10,
  "B", 14, 
  "C", 12,
  "D", 15
)

ggplot(data, aes(x = group, y = value)) +
  geom_col() + 
  labs(x = "Categorical variable",
       y = "Numeric variable") +
  theme(axis.title = element_text(size = 17)) 
```

---

## {#roadmap data-menu-title="Roadmap"} 

[Roadmap]{.slide-title}

<hr>

We'll first explore two (highly interchangeable) chart types for visualizing amounts across a categorical variable (great for highlighting rank or hierarchy):

<br>

[1. bar charts]{.body-text-m}  
[2. lollipop charts]{.body-text-m} (and dot plot variant)

<br>

. . . 

We'll also learn about a couple alternatives, which may be better suited for you data depending on the context, data structure, and narrative you want to tell:

<br>

[3. heat maps]{.body-text-m} (for when you have 2 categorical + 1 numeric variable and / or want to focus on patterns rather than precise amounts)

[4. dumbbell charts]{.body-text-m} (for visualizing change / difference between two groups)

---

## {#water-use-data data-menu-title="About the data"} 

[The data: USGS National Water Availability Assessment]{.slide-title3}

<hr>

[In January 2025, The [U.S. Geological Survey](https://www.usgs.gov/){target="_blank"} (USGS) released its new [National Water Availability Assessment](https://www.usgs.gov/special-topics/integrated-water-availability-assessments/science/integrated-water-availability-0){target="_blank"} (NWAA), which offers insights into water [supply](https://water.usgs.gov/nwaa-data/data/integrated-water-availability/iwa-assessment-outputs-conus-2025/availab/availab_iwa-assessment-outputs-conus-2025_README.html){target="_blank"}, [demand](https://water.usgs.gov/nwaa-data/data/integrated-water-availability/iwa-assessment-outputs-conus-2025/consum/consum_iwa-assessment-outputs-conus-2025_README.html){target="_blank"}, and quality across the U.S. The modeled water availability data that underlies the NWAA is made available through the online [National Water Availability Assessment Data Companion](https://www.usgs.gov/special-topics/integrated-water-availability-assessments/national-water-availability-assessment-0){target="_blank"} (NWDC). Here, users can interactively [subset and download data](https://water.usgs.gov/nwaa-data/subset-download){target="_blank"} or download files containing the [full spatial (conterminous US) and temporal (2010-2020) extent](https://water.usgs.gov/nwaa-data/data-file-directory?path=data/){target="_blank"} of the NWDC datasets.]{.body-text-s}

```{r nwaa-map}
#| eval: true
#| echo: false
#| out-width: "100%"
#| fig-align: "center"
knitr::include_graphics(here::here("course-materials", "images", "lecture-slides", "NWAA-map.png"))
```

::: {.center-text .body-text-s .gray-text}
Surface water-supply and use index (SUI) by 12-digit hydrologic unit codes (HUCs) for water years 2010-2020. Source: [Chapter F](https://pubs.usgs.gov/pp/1894/f/pp1894F.pdf){target="_blank"} of the U.S. Geological Survey Integrated Water Availability Assessment—2010–20.
:::

::: {.notes}
The NWDC provides regularly updated, model-based estimates of water availability and use, derived from USGS scientific models
:::

---

## {#HUCs data-menu-title="Understanding HUCs"} 

[The data: USGS National Water Availability Assessment]{.slide-title3}

<hr>

For today's lecture, we'll download the [full, integrated dataset](https://water.usgs.gov/nwaa-data/data-file-directory?path=data/integrated-water-availability/iwa-assessment-outputs-conus-2025/){target="_blank"} and filter for just the [California water resource region](https://en.wikipedia.org/wiki/California_water_resource_region#:~:text=Article,California%2C%20Nevada%2C%20and%20Oregon.){target="_bank"}, which is represented by the 2-digit hydrologic unit code (HUC), 18. We'll explore water availability and use across HUC 18's [ten subregions](https://en.wikipedia.org/wiki/California_water_resource_region#:~:text=%5B3%5D-,List%20of%20California%20water%20resource%20subregions,-%5Bedit%5D){target="_blank"}.

<br>

:::: {.columns}

::: {.column width="50%"}
```{r hucs-explained}
#| eval: true
#| echo: false
#| out-width: "70%"
#| fig-align: "center"
knitr::include_graphics(here::here("course-materials", "images", "lecture-slides", "hucs-explained.png"))
```

:::

::: {.column width="50%"}
```{r huc18-subregions}
#| eval: true
#| echo: false
#| out-width: "90%"
#| fig-align: "center"
knitr::include_graphics(here::here("course-materials", "images", "lecture-slides", "HUC18-subregions.png"))
```

:::

::::

<br>

::: {.footer}
**(Left)** Source: [Hydrologic Unit Codes (HUCs) Explained](https://nas.er.usgs.gov/hucs.aspx){target="_blank"}; Hydrologic units are identified using 12-digit hydrologic unit codes (HUC12s), which can be parsed into shorter codes representing larger spatial units (e.g. regions, subregions, subbasins). | **(Right)** California region (HUC 18), with its ten 4-digit subregion hydrologic unit boundaries. Source: [Wikipedia](https://en.wikipedia.org/wiki/California_water_resource_region#:~:text=%5B3%5D-,List%20of%20California%20water%20resource%20subregions,-%5Bedit%5D){target="_blank"}
:::

---

## {#data-wrangling data-menu-title="Data wrangling"} 

[Data wrangling]{.slide-title}

<hr>

[This integrated dataset includes modeled monthly estimates of [available water supply](https://water.usgs.gov/nwaa-data/data-catalog/sector/integrated-water-availability/model/iwa-assessment-outputs-conus-2025/variable/availab){target="_blank"}, [water consumption](https://water.usgs.gov/nwaa-data/data-catalog/sector/integrated-water-availability/model/iwa-assessment-outputs-conus-2025/variable/consum){target="_blank"}, and the [Surface Water-Supply and Use Index (SUI)](https://water.usgs.gov/nwaa-data/data-catalog/sector/integrated-water-availability/model/iwa-assessment-outputs-conus-2025/variable/sui){target=_blank} for hydrologic units across the conterminous US from 2010-2020.]{.body-text-s}

<!-- RUNS BUT DOES NOT PRINT -->

```{r data-wrangling-eval}
#| eval: true
#| echo: false

##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
##                                    setup                                 ----
##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#..........................load packages.........................
library(tidyverse)
library(janitor)
library(scales)

#..........................import data...........................
iwa_data <- read_csv(here::here("course-materials", "data", "lecture", "combined_iwa-assessment-outputs-conus-2025_CONUS_200910-202009_long.csv"))

#..................create df of subregions names.................
# data only contain HUC codes; must manually join names if we want to include those in our viz (which we do! we'll mainly be looking at CA subregions)
# subregions (& others) identified in: https://water.usgs.gov/GIS/wbd_huc8.pdf
# there may be a downloadable dataset containing HUCs & names out there...but I couldn't find it
subregion_names <- tribble(
  ~subregion_HUC, ~subregion_name,
  "1801", "Klamath-Northern California Coastal",
  "1802", "Sacramento",
  "1803", "Tulare-Buena Vista Lakes",
  "1804", "San Joaquin",
  "1805", "San Francisco Bay",
  "1806", "Central California Coastal",
  "1807", "Southern California Coastal",
  "1808", "North Lahontan", 
  "1809", "Northern Mojave-Mono Lake",
  "1810", "Southern Mojave-Salton Sea",
)

##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
##                                wrangle data                              ----
##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#......create df with just CA water resource region (HUC 18).....
ca_region <- iwa_data |> 

  # make nicer column names ----
  clean_names() |> 

  # create columns for 2-unit (region-level) & 4-unit (subregion-level) HUC using full 12-unit HUC ----
  mutate(region_HUC = str_sub(string = huc12_id, start = 1, end = 2),
         subregion_HUC = str_sub(string = huc12_id, start = 1, end = 4)) |> 
  
  # filter for just CA region (HUC 18) ----
  filter(region_HUC == "18") |> 

  # separate year and month into two columns ----
  separate_wider_delim(cols = year_month,
                       delim = "-",
                       names = c("year", "month")) |> 

  # convert year and month from chr to num ---                            
  mutate(year = as.numeric(year),
         month = as.numeric(month)) |> 
  
  # join subregion names ----
  left_join(subregion_names) |> 
  
  # keep necessary columns & reorder in more logical way -----
  select(year, month, huc12_id, region_HUC, subregion_HUC, subregion_name, availab_mm_mo, consum_mm_mo, sui_frac)

# ##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ##                            explore missing data                          ----
# ##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# sub1805 <- ca_region |> 
#   filter(subregion_HUC == "1805") 

# see_NAs <- ca_region |> 
#   group_by(year) |> 
#   naniar::miss_var_summary() |>
#   filter(variable == "availab_mm_mo")

# avail <- sub1805 |> select(availab_mm_mo)
# missing_avail <- naniar::vis_miss(avail)
```

<!-- PRINTS BUT DOES NOT RUN -->

```{r data-wrangling-echo}
#| eval: false
#| echo: true

##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
##                                    setup                                 ----
##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#..........................load packages.........................
library(tidyverse)
library(janitor)
library(scales)

#..........................import data...........................
iwa_data <- read_csv(here::here("week3", "data", "combined_iwa-assessment-outputs-conus-2025_CONUS_200910-202009_long.csv"))

#..................create df of subregions names.................
# data only contain HUC codes; must manually join names if we want to include those in our viz (which we do! we'll mainly be looking at CA subregions)
# subregions (& others) identified in: https://water.usgs.gov/GIS/wbd_huc8.pdf
# there may be a downloadable dataset containing HUCs & names out there...but I couldn't find it
subregion_names <- tribble(
  ~subregion_HUC, ~subregion_name,
  "1801", "Klamath-Northern California Coastal",
  "1802", "Sacramento",
  "1803", "Tulare-Buena Vista Lakes",
  "1804", "San Joaquin",
  "1805", "San Francisco Bay",
  "1806", "Central California Coastal",
  "1807", "Southern California Coastal",
  "1808", "North Lahontan", 
  "1809", "Northern Mojave-Mono Lake",
  "1810", "Southern Mojave-Salton Sea",
)

##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
##                                wrangle data                              ----
##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#......create df with just CA water resource region (HUC 18).....
ca_region <- iwa_data |> 

  # make nicer column names ----
  clean_names() |> 

  # create columns for 2-unit (region-level) & 4-unit (subregion-level) HUC using full 12-unit HUC ----
  mutate(region_HUC = str_sub(string = huc12_id, start = 1, end = 2),
         subregion_HUC = str_sub(string = huc12_id, start = 1, end = 4)) |> 
  
  # filter for just CA region (HUC 18) ----
  filter(region_HUC == "18") |> 

  # separate year and month into two columns ----
  separate_wider_delim(cols = year_month,
                       delim = "-",
                       names = c("year", "month")) |> 

  # convert year and month from chr to num ---                            
  mutate(year = as.numeric(year),
         month = as.numeric(month)) |> 
  
  # join subregion names ----
  left_join(subregion_names) |> 
  
  # keep necessary columns & reorder in more logical way -----
  select(year, month, huc12_id, region_HUC, subregion_HUC, subregion_name, availab_mm_mo, consum_mm_mo, sui_frac)
```

::: {footer}
"In equation-form: Total water availability = net water delivered to next downstream HUC12 (baseflow + quickflow + upstream inputs) - total consumptive loss. In some cases, total water availability can be negative, implying that consumptive losses are greater than natural supply. This situation can occur when human water consumption is sustained through deep groundwater sources, transbasin diversion, or drawdown of local storage."
https://water.usgs.gov/nwaa-data/data/integrated-water-availability/iwa-assessment-outputs-conus-2025/availab/availab_iwa-assessment-outputs-conus-2025_README.html#:~:text=Technical%20Description:,or%20drawdown%20of%20local%20storage.
:::

---

##  {#bar-lollipop data-menu-title="## Bar & lollipop ##" background="#047C90"}

<div class="vertical-center">
<center><div class = "custom-subtitle">Bar charts & lollipop charts</div></center>
<center><div class="custom-subtitle3">*interchangeable | focus is on highest and lowest values (as well as overall rank / hierarchy) | best for visualizing amounts across a single categorical variable | encode values using LENGTH*</div></center>
</div>

---

## {#bar-lolli-1group data-menu-title="Bar & Lollipop plots (1 group)"} 

[Bar & lollipop plots to visualize rankings]{.slide-title}

<hr>


[Let's first look at the **long-term mean Surface Water-Supply and Use Index (SUI) across the ten HUC 18 subregions**. Higher SUI values indicate greater water stress. Each bar and lollipop represents the mean SUI for a given subregion, calculated by averaging all monthly SUI values from 2010–2020.]{.body-text-s}

:::: {.columns}

::: {.column width="50%"}
```{r basic-bar}
#| eval: true
#| echo: true
#| fig-align: "center"
ca_region |> 
  group_by(subregion_name) |> 
  summarise(mean_sui_2010_2020 = mean(sui_frac, na.rm = TRUE)) |> 
  ggplot(aes(x = subregion_name, y = mean_sui_2010_2020)) +
  geom_col() 
```
:::

::: {.column width="50%"}
```{r basic-lollipop}
#| eval: true
#| echo: true
#| fig-align: "center"
ca_region |> 
  group_by(subregion_name) |> 
  summarise(mean_sui_2010_2020 = mean(sui_frac, na.rm = TRUE)) |> 
  ggplot(aes(x = subregion_name, y = mean_sui_2010_2020)) +
  geom_point() +
  geom_linerange(aes(ymin = 0, ymax = mean_sui_2010_2020))
```

:::

::::

::: {.footer}
From the [USGS Glossary](https://water.usgs.gov/vizlab/water-availability/glossary){target="_blank"}: *"A high index value indicates that a high proportion of the average supply is either consumed by human use or unavailable because of climatic variation, leading to high water stress."*
:::

::: {.notes}
You might also consider using `ggalt::geom_lollipop()` for a simple lollipop chart, though you may run into limitations when creating more complex charts.
:::

---

## {#coord-flip-theme data-menu-title="Flip axes / update label angle"} 

[Make space for long x-axis labels]{.slide-title}

<hr>

[We never want to leave overlapping or super squished text (especially axis text) on our plots. Let's give those long x-axis labels some breathing room using by reversing your axes mappings! Alternatively, you can leave your mappings as-is and apply `coord_flip()`.]{.body-text-s}

:::: {.columns}

::: {.column width="50%"}
```{r flipped-bar}
#| eval: true
#| echo: true
#| fig-align: "center"
#| code-line-numbers: "4"
ca_region |> 
  group_by(subregion_name) |> 
  summarise(mean_sui_2010_2020 = mean(sui_frac, na.rm = TRUE)) |> 
  ggplot(aes(x = mean_sui_2010_2020, y = subregion_name)) +
  geom_col() 
```

:::

::: {.column width="50%"}
```{r flipped-lollipop}
#| eval: true
#| echo: true
#| fig-align: "center"
#| code-line-numbers: "4,6"
ca_region |> 
  group_by(subregion_name) |> 
  summarise(mean_sui_2010_2020 = mean(sui_frac, na.rm = TRUE)) |> 
  ggplot(aes(x = mean_sui_2010_2020, y = subregion_name)) +
  geom_point() +
  geom_linerange(aes(xmin = 0, xmax = mean_sui_2010_2020))
```

:::

::::

::: {.footer}
We also want to avoid the temptation to [rotate our axis text](https://clauswilke.com/dataviz/visualizing-amounts.html){target="_blank"} (or any text, for that matter). Rotated text forces readers to tilt their heads or strain their eyes to read labels. Flipping the axes is almost always a better, more readable alternative.
:::

---

## {#arrange-bars data-menu-title="Arrange bars"} 

[Reordering groups helps readers more quickly derive insight]{.slide-title3}

<hr>

[Here, we use `forcats::fct_reorder()` to reorder the levels of our y-axis variable, `name`, based on a numeric variable, `mean_sui_2010_2020`.]{.body-text-s}

:::: {.columns}

::: {.column width="50%"}
```{r ordered-bars}
#| eval: true
#| echo: true 
#| code-line-numbers: "4"
#| fig-align: "center"
ca_region |> 
  group_by(subregion_name) |> 
  summarise(mean_sui_2010_2020 = mean(sui_frac, na.rm = TRUE)) |> 
  mutate(subregion_name = fct_reorder(.f = subregion_name, .x = mean_sui_2010_2020)) |>
  ggplot(aes(x = mean_sui_2010_2020, y = subregion_name)) +
  geom_col() 
```
:::

::: {.column width="50%"}
```{r ordered-lollipops}
#| eval: true
#| echo: true
#| code-line-numbers: "4"
#| fig-align: "center"
ca_region |> 
  group_by(subregion_name) |> 
  summarise(mean_sui_2010_2020 = mean(sui_frac, na.rm = TRUE)) |> 
  mutate(subregion_name = fct_reorder(.f = subregion_name, .x = mean_sui_2010_2020)) |>
  ggplot(aes(x = mean_sui_2010_2020, y = subregion_name)) +
  geom_point() +
  geom_linerange(aes(xmin = 0, xmax = mean_sui_2010_2020))
```
:::

::::

::: {.footer}
Check out [this blog post](https://blog.albertkuo.me/post/2022-01-04-reordering-geom-col-and-geom-bar-by-count-or-value/){target="_blank"} for more useful reordering approaches / examples.
:::

---

## {#add-labels data-menu-title="Add labels"} 

[Add direct labels if the exact values are important]{.slide-title2}

<hr>

[`geom_text()` allows us to map values from a column (here, `mean_sui_2010_2020`) directly onto the plot as text labels. This can be helpful if it's important for readers to know precise values. Avoid adding if relative comparisons are enough or if it's easy to estimate the length of a bar against its axis.]{.body-text-s}

:::: {.columns}

::: {.column width="50%"}
```{r labeled-bar}
#| eval: true
#| echo: true 
#| code-line-numbers: "7"
#| fig-align: "center"
ca_region |> 
  group_by(subregion_name) |> 
  summarise(mean_sui_2010_2020 = mean(sui_frac, na.rm = TRUE)) |> 
  mutate(subregion_name = fct_reorder(.f = subregion_name, .x = mean_sui_2010_2020)) |>
  ggplot(aes(x = mean_sui_2010_2020, y = subregion_name)) +
  geom_col() +
  geom_text(aes(label = round(mean_sui_2010_2020, 2)), hjust = 1.2, color = "white") 
```
:::

::: {.column width="50%"}
```{r labeled-lollipop}
#| eval: true
#| echo: true
#| code-line-numbers: "8,9"
#| fig-align: "center"
#| out-width: "80%"
ca_region |> 
  group_by(subregion_name) |> 
  summarise(mean_sui_2010_2020 = mean(sui_frac, na.rm = TRUE)) |> 
  mutate(subregion_name = fct_reorder(.f = subregion_name, .x = mean_sui_2010_2020)) |>
  ggplot(aes(x = mean_sui_2010_2020, y = subregion_name)) +
  geom_point() +
  geom_linerange(aes(xmin = 0, xmax = mean_sui_2010_2020)) +
  geom_text(aes(label = round(mean_sui_2010_2020, 2)), hjust = -0.3) + 
  scale_x_continuous(limits = c(0, 0.6))
```
:::

::::

<!-- ::: {.footer}
For some more advanced label manipulation, see [A Quick How-to on Labelling Bar Graphs in ggplot2](https://www.cedricscherer.com/2021/07/05/a-quick-how-to-on-labelling-bar-graphs-in-ggplot2/){target="_blank"}, by Cédric Scherer 
::: -->

---

## {#col-vs-bar data-menu-title="geom_col() vs. geom_bar()"} 

[An aside: `geom_col()` vs. `geom_bar()`]{.slide-title2}

<hr>

:::: {.columns} 

::: {.column width="50%"}
[**Use `geom_col()` when you want the heights of your bars to represent values in your data** (i.e. you have a variable in your data set that maps to the length (or height) of your bars). Here, we already have a numeric variable in our data set called, `mean_sui_2010_2020`, which is mapped to the length of each bar in our plot:]{.body-text-s}

```{r geom_col-comp}
#| eval: true
#| echo: true 
#| out-width: "75%"
#| fig-align: "center"
ca_region |> 
  group_by(subregion_name) |> 
  summarise(mean_sui_2010_2020 = mean(sui_frac, na.rm = TRUE)) |> 
  ggplot(aes(x = mean_sui_2010_2020, y = subregion_name)) +
  geom_col() 
```
:::

::: {.column width="50%"}
[**Use `geom_bar()` if you want the heights of your bars to be proportional to the number of cases in each group.**  E.g. if we want to know how many observations exist for each subregion (note that we don't have a `count` column in our data frame -- `geom_bar()` groups by `subregion_name` then counts the number of observations for each `subregion_name` group):]{.body-text-s}

```{r geom-bar-comp}
#| eval: true
#| echo: true
#| out-width: "75%"
#| fig-align: "center"
ggplot(ca_region, aes(x = subregion_name)) +
  geom_bar() +
  scale_y_continuous(label = scales::label_comma()) + 
  coord_flip() 
```
:::

::::

::: {.footer}
Each of our subregions have a different number of subwatersheds (represented by HUC12 IDs), which is why we have a different number of rows (observations) for each
:::

---

## {#truncated-axis data-menu-title="Truncated axis"} 

[IMPORTANT: Do not truncate axes]{.slide-title2}

<hr>

::: {.center-text .body-text-m}
Because bar (and related) charts **encode values by length from zero**, cutting the axis exaggerates differences and is misleading. The axis **must** start at zero.
:::

[Truncated axes leads viewers to perceive illustrated differences as larger or more important than they actually are (i.e. a truncation effect). [Yang et al. (2021)](https://doi.org/10.1016/j.jarmac.2020.10.002){target="_blank"} empirically tested this effect and found that this truncation effect persisted even after viewers were taught about the effects of y-axis truncation.]{.body-text-s} 

<br>

```{r yang-etal-2021}
#| eval: true
#| echo: false
#| fig-align: "center"
#| out-width: "80%"
knitr::include_graphics(here::here("course-materials", "images", "lecture-slides", "yang-etal-2021.png"))
```

::: {.center-text .gray-text .body-text-s}
Figure 2 from Yang et al. 2021. The left-most plot without a truncated y-axis was presented to the control group of viewers. The right-most plot with a truncated y-axis was presented to the test group of viewers.
:::

<br>

::: {.footer}
Yang et al. (2021) Truncating bar graphs persistently misleads viewers. *Journal of Applied Research in Memory and Cognition* 10:2, 298-311. [https://doi.org/10.1016/j.jarmac.2020.10.002](https://doi.org/10.1016/j.jarmac.2020.10.002){target="_blank"}
:::

---

## {#dot-plot data-menu-title="Dot plots "} 

[But you can cut the y-axis of dot plots!]{.slide-title}

<hr>

::: {.center-text .body-text-m}
Because dot plots **encode values by position**, truncating the axis doesn’t distort comparisons. The axis **does not have to** start at zero.
:::

[When bars are all long and have nearly the same length, the eye is drawn to the middle of the bars rather than to their end points. A lollipop plot is a bit less distracting (less ink), but still difficult to differentiate risk scores across counties. When we limit the axis range in a dot plot, it becomes easier to identify differences in the max and min values.]{.body-text-s} 

:::: {.columns}
 
::: {.column width="33%"}
```{r nj-bar}
#| eval: true
#| echo: false
#| out-width: "100%"
#| fig-align: "center"
knitr::include_graphics(here::here("course-materials", "images", "lecture-slides", "nj-bar.png"))
```
:::

::: {.column width="33%"}
```{r nj-lollipop}
#| eval: true
#| echo: false
#| out-width: "100%"
#| fig-align: "center"
knitr::include_graphics(here::here("course-materials", "images", "lecture-slides", "nj-lollipop.png"))
```
:::

::: {.column width="33%"}
```{r nj-dot}
#| eval: true
#| echo: false
#| out-width: "100%"
#| fig-align: "center"
knitr::include_graphics(here::here("course-materials", "images", "lecture-slides", "nj-dot.png"))
```
:::

::::

<br>

::: {.footer}
Create a dot plot using `geom_point()`, then adjust `panel.grid` lines inside `theme()` | You'll see these county-level [FEMA National Risk Index](https://www.fema.gov/flood-maps/products-tools/national-risk-index){target="_blank"} scores in [Homework #2](https://eds-240-data-viz.github.io/course-materials/assignments/HW2.html){target="_blank"}!
:::

---

## {#cat-not-cont data-menu-title="Bar plots for categorical data"} 

[Be cautious when using bar plots to summarize continuous data]{.slide-title3}

<hr>

[**Bar plots shine when you need to compare counts** (e.g. populations size of different countries). *However*, you should proceed with caution when using bar plots to visualize the distribution of / summarize your data. Doing so can be *misleading*, particularly when you have small sample sizes. Why?]{.body-text-s}

. . .

- [bar plots hide the distribution of the underlying data (many different distributions can lead to the same plot)]{.body-text-s}

- [when used this way, the height of the bar (typically) represents the mean of the data, which can cause readers to incorrectly infer that the data are normally distributed with no outliers (this of course *may* be true in some cases, but certainly not always)]{.body-text-s}

:::: {.columns}

::: {.column width="50%"}
```{r weissgerber-etal-2015}
#| eval: true
#| echo: false
#| fig-align: "center"
#| out-width: "70%"
knitr::include_graphics(here::here("course-materials", "images", "lecture-slides", "weissgerber-etal-2015.png"))
```
:::

::: {.column width="50%"}
```{r horst-barplot}
#| eval: true
#| echo: false
#| fig-align: "center"
#| out-width: "70%"
#| fig-alt: "Main text: 'Are your summary statistics hiding something?' On the left is a opaque gray bar plot with an error bar, looking mischievous while hiding individual data points in a net behind it. On the right is a transparent bar plot with an error bar, looking exposed, with individual data points exposed and dancing. The bottom four data points have arms that spell 'YMCA' as if dancing to the Village People."
knitr::include_graphics(here::here("course-materials", "images", "lecture-slides", "horst-barplot.png"))
```

:::

::::

<br>

::: {.footer}
**Left:** [Figure 1](https://journals.plos.org/plosbiology/article?id=10.1371%2Fjournal.pbio.1002128#pbio-1002128-g001){target="_blank"} from Weissgerber et al. (2015) Beyond Bar and Line Graphs: Time for a New Data Presentation Paradigm. *PLOS Biology* 13:e1002128. [https://doi.org/10.1371/journal.pbio.1002128](https://doi.org/10.1371/journal.pbio.1002128){target="_blank"} | **Right:** Artwork by [Allison Horst](https://allisonhorst.com/){target="_blank"}
:::

::: {.notes}
- It’s okay to use bar (or related) plots anytime you’re comparing counts (e.g. population size of different countries, total earnings by group) — this is really where bar plots shine!
If you are using a bar plot to visualize the distribution/summarize of your data, you should consider if there are better alternative options (e.g. box plots) — if you are inclined to include some sort of error bar / standard deviation on your bar plot, you are likely attempting to use your bar plot to visualize a distribution. Why is this wrong?

- It’s not necessarily wrong, but it can be misleading, particularly when dealing with small sample sizes because (1) it’s impossible to know the distribution of the underlying data, and many different data distributions can lead to the same bar plot (see figure on lecture 4.1 slide 15). (2) When used this way, the height of the bar (typically) represents the mean of the data, which can cause readers to incorrectly infer that the data are normally distributed with no outliers (this of course may be true in certain cases, but certainly is not always true…particularly when dealing with small sample sizes where outliers are common)

Bar plots are very commonly used in both ways (comparing counts and visualizing distributions) — for example, see [this online resource](https://www.labxchange.org/library/items/lb:LabXchange:e034541a:html:1) that reviews how to interpret both forms of a bar plot. However, you should proceed with extreme caution when using bar plots to summarize your data for the reasons outlined above. If you do choose to use a bar plot, consider layering on the raw data points as well (this isn’t always feasible with larger data sets). 
:::

---

##  {#stacked-bar-chart data-menu-title="## Stacked Bar ##" background="#047C90"}

<div class="vertical-center">
<center><div class = "custom-subtitle">Stacked bar charts</div></center>
<center><div class="custom-subtitle3">*great for part-to-whole comparisons | use a percentage stacked bar chart when you want the focus to be on relative proportions | encode values using LENGTH*</div></center>
</div>

---

## {#stacked-bar data-menu-title="Stacked bar plot"} 

[Stacked bar plots for showing parts of a whole]{.slide-title2}

<hr>

[The USGS classifies **[SUI](https://water.usgs.gov/nwaa-data/data-catalog/sector/integrated-water-availability/model/iwa-assessment-outputs-conus-2025/variable/sui){target="_blank"}** into five categories: *Very low (0.0 to <0.2), Low (0.2 to <0.4), Moderate (0.4 to <0.6), High (0.6 to <0.8), and Severe (0.8 to 1)*. **Let's say we want to look at how California subwatersheds (HUC12s) are distributed across these categories by month from 2010–2020.** We can use a stacked bar plot, each bar represents a month and segments represent the number of subwatersheds in each SUI category. Let's first do a bit of wrangling:]{.body-text-s}

:::: {.columns}

::: {.column width="50%"}
```{r stacked-bar-ex}
#| eval: true
#| echo: false
#| out-width: "100%"
#| fig-align: "center"
knitr::include_graphics(here::here("course-materials", "images", "lecture-slides", "stacked-bar-ex.png"))
```
:::

::: {.column width="50%"}
```{r wrangle-stacked}
#| eval: true
#| echo: true

sui_severity <- ca_region |>
  mutate(
    sui_category = case_when(
      sui_frac < 0.2 ~ "Very low",
      sui_frac >= 0.2 & sui_frac < 0.4 ~ "Low",
      sui_frac >= 0.4 & sui_frac < 0.6 ~ "Moderate",
      sui_frac >= 0.6 & sui_frac < 0.8 ~ "High",
      sui_frac >= 0.8 & sui_frac <= 1 ~ "Severe",
      TRUE ~ NA
    )) |> 
  group_by(month, sui_category) |> 
  summarize(tot_num_sui = n()) |> 
  drop_na(sui_category) |> 
  mutate(month = month.abb[month],
         month = factor(month, levels = c(month.abb[10:12], month.abb[1:9]))) # order months Oct > Sep (water year)
```
:::
::::

```{r stacked-bar-countdown}
countdown::countdown(
  minutes = 3,
  # left = 0, right = 0,
  # Fanfare when it's over
  play_sound = TRUE,
  color_border              = "#FFFFFF",
  color_text                = "#7aa81e",
  color_running_background  = "#7aa81e",
  color_running_text        = "#FFFFFF",
  color_finished_background = "#ffa07a",
  color_finished_text       = "#FFFFFF",
  font_size = "2em",
  )
```

::: {.footer}
Image source: [Data Viz Project](https://datavizproject.com/data-type/stacked-bar-chart/){target="_blank"}. **Take a few minutes to run and understand this wrangling code with your learning partners. Note down any questions you have.**
:::

---

## {#stacked-bar-improvements data-menu-title="Stacked bar plot improvements?"} 

[What improvements should we make?]{.slide-title}

<hr>

[The code for a stacked bar plot is not so different from a standard bar plot -- just add a numeric variable as your `fill`:]{.body-text-s}

```{r improvements-needed}
#| eval: true
#| echo: true
#| out-width: "100%"
#| fig-align: "center"
ggplot(sui_severity, aes(x = month, y = tot_num_sui, fill = sui_category)) +
  geom_col()
```

```{r improvements-countdown}
countdown::countdown(
  minutes = 1,
  # left = 0, right = 0,
  # Fanfare when it's over
  play_sound = TRUE,
  color_border              = "#FFFFFF",
  color_text                = "#7aa81e",
  color_running_background  = "#7aa81e",
  color_running_text        = "#FFFFFF",
  color_finished_background = "#ffa07a",
  color_finished_text       = "#FFFFFF",
  font_size = "2em",
  )
```

. . .

[To make interpretation easier, we should **reorder** our `sui-categories` so that the most important (Severe) is on the bottom (making it easier to read against the y-axis; we should update our legend order to reflect this as well), convert our y-axis values to **percentages**, and update our **colors** (we can adopt those used by USGS -- see [this slide](SLIDES-amounts-rankings.qmd#water-use-data){target="_blank"})]{.body-text-s}

---

## {#revise-wrangling-totals data-menu-title="Revise wrangling 1"} 

[Let's first update our wrangling code]{.slide-title}

<hr>

To convert our absolute values into percentages, we'll need to calculate:

$$(total\:SUI\:values\:per\:category\:/\:total\:SUI\:values\:per\:month)*100$$ 

In theory, we should have the same number of SUI values per month, but it's good to check:

```{r tot_sui_per_month}
#| eval: true
#| echo: true
tot_sui_per_month <- ca_region |> 
  group_by(month) |> 
  count() |> 
  rename(tot_sui_per_month = n)

tot_sui_per_month
```

---

## {#revise-wrangling-update-df data-menu-title="Revise wrangling 2"} 

[Let's first update our wrangling code]{.slide-title}

<hr>

Then, we need to calculate our percentages and reorder our category levels: 

```{r updated-wrangling}
#| eval: true
#| echo: true
#| code-line-numbers: "14,17-20"
sui_severity <- ca_region |>
  mutate(
    sui_category = case_when(
      sui_frac < 0.2 ~ "Very low",
      sui_frac >= 0.2 & sui_frac < 0.4 ~ "Low",
      sui_frac >= 0.4 & sui_frac < 0.6 ~ "Moderate",
      sui_frac >= 0.6 & sui_frac < 0.8 ~ "High",
      sui_frac >= 0.8 & sui_frac <= 1 ~ "Severe",
      TRUE ~ NA
    )) |> 
  group_by(month, sui_category) |> 
  summarize(tot_sui_per_cat = n()) |> 
  drop_na(sui_category) |> 
  left_join(tot_sui_per_month) |> # join total number of SUI observations per month
  mutate(month = month.abb[month],
         month = factor(month, levels = c(month.abb[10:12], month.abb[1:9]))) |> 
  mutate(perc = (tot_sui_per_cat/tot_sui_per_month) * 100) |> # add col with calculated %s
  mutate(sui_category = factor(sui_category, # reorder categories
                               levels = c("Very low", "Low",
                                          "Moderate", "High", "Severe")))
```

---

## {#percentage-stacked-bar data-menu-title="Create percentage stacked bar chart"} 

[Convert to percentage stacked bar chart]{.slide-title}

<hr>

```{r percentage-stacked}
#| eval: true
#| echo: true
#| out-width: "100%"
#| fig-align: "center"
#......................create color palette......................
# pulled hex codes from USGS map using ColorZilla Chrome extension
sui_colors <- c("Severe" = "#720C0F", 
                "High" = "#F68939", 
                "Moderate" = "#FBF7BF", 
                "Low" = "#AAD9EA", 
                "Very low" = "#217AB5")

#...................create % stacked bar chart...................
ggplot(sui_severity, aes(x = month, y = perc, fill = sui_category)) +
  geom_col() +
  scale_fill_manual(values = sui_colors) +
  scale_y_continuous(labels = scales::label_percent(scale = 1))  
```

::: {.footer}
Inspiration for this viz came directly from the [U.S. Geological Survey Integrated Water Availability Assessment—2010–20 (Ch. F)](https://pubs.usgs.gov/pp/1894/f/pp1894F.pdf){target="_blank"} (see page 9) | The [`{scales}` package](https://scales.r-lib.org/){target="_blank"} is a true label-editing hero! Keep this one in mind whenever you need to reformat axis labels.
:::

---

##  {#heatmaps data-menu-title="## Heatmaps ##" background="#047C90"}

<div class="vertical-center">
<center><div class = "custom-subtitle">Heatmaps</div></center>
<center><div class="custom-subtitle3">*great option for visualizing matrices of data (e.g. 2 categorical + 1 numeric variable) | focus is on patterns rather than precise amounts | consider audience familiarity (may require more explanation than a bar plot) | encode values using COLOR*</div></center>
</div>

---

## {#heatmap-example data-menu-title="Heatmap (example)"} 

[Heatmap for 2 categorical + 1 numeric variable]{.slide-title2}

<hr>

[Now let's look at **how water stress changes through time for each of the ten HUC 18 subregions**. We can use a heatmap to create a matrix that displays annual mean SUI values (numeric, continuous), calculated by averaging monthly observations within each year, by subregion (categorical) and year (categorical). We need to do a bit of wrangling:]{.body-text-s}

:::: {.columns}
::: {.column width="50%"}
```{r heatmap-example}
#| eval: true
#| echo: false
#| out-width: "100%"
#| fig-align: "center"
knitr::include_graphics(here::here("course-materials", "images", "lecture-slides", "heatmap-example.png"))
``` 
:::
::: {.column width="50%"}

```{r heatmap-wrangling}
#| eval: true
#| echo: true
#...........df of annual mean SUI by subregion & year ...........
heatmap_data <- ca_region |> 
  group_by(subregion_name, year) |> 
  summarize(annual_mean_sui = mean(sui_frac, na.rm = TRUE)) |> 
  ungroup()

#.determine order of subregions based on highest avg SUI in 2015.
# it's likely that you'll first try making a plot with `heatmap_data`, then return to wrangle the order once you decide how best to arrange your groups
order_2015 <- heatmap_data |> 
  filter(year == 2015) |> 
  arrange(annual_mean_sui) |> 
  mutate(order = row_number()) |> 
  select(annual_mean_sui, order) 

#........join order with rest of data to set factor levels.......
heatmap_order <- heatmap_data |> 
  left_join(order_2015) |> 
  mutate(name = fct_reorder(.f = subregion_name, .x = order))
```
:::
::::

::: {.footer}
Image source: [Data Viz Project](https://datavizproject.com/data-type/heat-map/){target=_"blank"}. We can make heatmaps using `geom_tile()`.
:::

---

## {#heatmap-plot data-menu-title="Heatmap (plot)"} 

[Heatmap for 2 categorical + 1 numeric variable]{.slide-title2}

<hr>

[How you order your groups can (1) make it easier for readers to extract patterns and comparisons, and (2) shape the story the visualization tells. Here, subregions are ordered based on their average annual SUI in 2015, the end of a particularly dry stretch of years. ***How else might you consider ordering these groups?***]{.body-text-s}

<br>

:::: {.columns}
::: {.column width="60%"}
```{r heatmap-plot}
#| eval: true
#| echo: false
#| out-width: "100%"
#| fig-align: "center"
ggplot(heatmap_order, aes(x = year, y = subregion_name, fill = annual_mean_sui)) +
  geom_tile() +
  labs(fill = "Annual Mean Surface Water-Supply and\nUse Index (SUI)") + # caption = "A higher index value indicates greater water stress."
  scale_fill_viridis_c() +
  scale_x_continuous(breaks = seq(2010, 2020, by = 2)) +
  guides(fill = guide_colorbar(barwidth = 15, barheight = 0.75, title.position = "top")) +
  theme_minimal() +
  theme(
    legend.position = "top",
    axis.title = element_blank(),
    panel.grid = element_blank()
  )
``` 
:::
::: {.column width="40%"}

```{r heatmap-plot-code}
#| eval: false
#| echo: true
ggplot(heatmap_order, aes(x = year, y = subregion_name, fill = annual_mean_sui)) +
  geom_tile() +
  labs(fill = "Annual Mean Surface Water-Supply and\nUse Index (SUI)") + # caption = "A higher index value indicates greater water stress."
  scale_fill_viridis_c() +
  scale_x_continuous(breaks = seq(2010, 2020, by = 2)) +
  guides(fill = guide_colorbar(barwidth = 15, barheight = 0.75, title.position = "top")) +
  theme_minimal() +
  theme(
    legend.position = "top",
    axis.title = element_blank(),
    panel.grid = element_blank()
  )
```
:::
::::

---

##  {#dumbbell-plots data-menu-title="## Dumbbell plots ##" background="#047C90"}

<div class="vertical-center">
<<center><div class = "custom-subtitle">Dumbbell plots</div></center>
<center><div class="custom-subtitle3">*highlights magnitude and direction of change (or difference) between two values within a category | shows exact values, but focus is on the difference between values | encode values using POSITION*</div></center>
</div>

---

## {#dumbbell-example data-menu-title="Dumbbell example"} 

[Dumbbell plot for 1 categorical + 2 within-category numeric variables]{.slide-title3}

<hr>

Let’s say we want to **compare mean monthly water [availability](https://water.usgs.gov/nwaa-data/data-catalog/sector/integrated-water-availability/model/iwa-assessment-outputs-conus-2025/variable/availab){target="_blank"} and [consumption](https://water.usgs.gov/nwaa-data/data-catalog/sector/integrated-water-availability/model/iwa-assessment-outputs-conus-2025/variable/consum){target="_blank"} in the Santa Barbara Coastal subbasin (HUC8: 18060013) across the years 2010-2020**. We can use a dumbbell (aka Cleveland) plot to display the average amount of water (mm; numeric) available vs. consumed (categorical), by month (categorical).

<br>

```{r dumbbell-example}
#| eval: true
#| echo: false
#| out-width: "100%"
#| fig-align: "center"
knitr::include_graphics(here::here("course-materials", "images", "lecture-slides", "dumbbell-example.png"))
```

::: {.footer}
Image source: [Data Viz Project](https://datavizproject.com/data-type/dumbbell-plot/){target="_blank"}
:::

---

## {#dumbbell-definitions data-menu-title="Dumbbell definitions"} 

[Dumbbell plot for 1 categorical + 2 within-category numeric variables]{.slide-title3}

<hr>

:::: {.columns}
::: {.column width="50%"}
- [[**{{< fa droplet title="water droplet" >}} Total Water Availability (`availab_mm_mo`)**]{.teal-text} = total amount of water exiting a particular 12-digit hydrologic unit (HUC12), calculated as the net of streamflow inputs minus total consumptive water use locally and upstream; can be negative, implying that consumptive losses > natural supply (in these cases, human consumption is sustained through deep groundwater sources, transbasin diversion, or drawdown of local storage)]{.body-text-s}

- [[**{{< fa faucet-drip title="dripping faucet" >}} Total Water Consumption (`consum_mm_mo`)**]{.teal-text} = total amount of water consumed for public supply, thermoelectric power, and crop irrigation; refers to the permanent removal of water from the local environment]{.body-text-s}
:::
::: {.column width="50%"}
```{r dumbbell-wrangling}
#| eval: true
#| echo: true
#| out-width: "50%"
#| fig-align: "center"
sbc_subbasin_monthly <- ca_region |> 
  mutate(subbasin_HUC = str_sub(string = huc12_id, start = 1, end = 8)) |> 
  filter(subbasin_HUC == "18060013") |> #
  group_by(month) |> 
  summarize(mean_avail = mean(availab_mm_mo, na.rm = TRUE),
            mean_consum = mean(consum_mm_mo, na.rm = TRUE)) |> 
  mutate(month = month.abb[month],
         month = factor(month, levels = rev(c(month.abb[10:12], month.abb[1:9]))))
```
:::
::::

---

## {#dumbbell-plot-example data-menu-title="Dumbbell plot - water available vs. consumed (plot)"} 

[Dumbbell plot for 1 categorical + 2 within-category numeric variables]{.slide-title3}

<hr>

[Here, it makes sense to order the y-axis groups chronologically (Oct > Sep). If your grouping variable is not inherently chronological (e.g. if comparing water availability and consumption across different subbasins), a common approach is to order groups by a mean or max value. See this [archived version](ARCHIVE/SLIDES-amounts-rankings-jobs.qmd#dumbbell-plot-example){target="_blank"} of the lecture for an alternative dumbbell plot example where we order differently.]{.body-text-s}

:::: {.columns}
::: {.column width="50%"}
```{r dumbbell-plot}
#| eval: true
#| echo: false
#| out-width: "100%"
#| fig-align: "center"
ggplot(sbc_subbasin_monthly) +
  geom_linerange(aes(y = month,
                     xmin = mean_consum, xmax = mean_avail)) + 
  geom_point(aes(x = mean_avail, y = month), 
             color = "#448F9C", 
             size = 5.5,
             stroke = 2) +
  geom_point(aes(x = mean_consum, y = month), 
             color = "#9C7344", 
             fill = "white",
             shape = 21,
             size = 5.5,
             stroke = 2) +
  labs(x = "Mean monthly water supply & demand (mm)") +
  theme(axis.title.y = element_blank())
```
:::
::: {.column width="50%"}
```{r dumbbell-plot-code}
#| eval: false
#| echo: true
ggplot(sbc_subbasin_monthly) +
  geom_linerange(aes(y = month,
                     xmin = mean_consum, xmax = mean_avail)) + 
  ggeom_point(aes(x = mean_avail, y = month), 
             color = "#448F9C", 
             size = 5.5,
             stroke = 2) +
  geom_point(aes(x = mean_consum, y = month), 
             color = "#9C7344", 
             fill = "white",
             shape = 21,
             size = 5.5,
             stroke = 2) +
  labs(x = "Mean monthly water supply & demand (mm)") +
  theme(axis.title.y = element_blank())
```
:::
::::

<br>

::: {.footer}
**There are more modifications we would need to make before calling this plot done (e.g. adding a title, legend info, theme) -- we'll come back to this in a later lecture!**
:::

::: {.notes}
- Example viz: <https://www.usgs.gov/media/images/water-supply-vs-demand-2010-2020>
- Availability README: https://water.usgs.gov/nwaa-data/data/integrated-water-availability/iwa-assessment-outputs-conus-2025/availab/availab_iwa-assessment-outputs-conus-2025_README.html
- Consumption README: https://water.usgs.gov/nwaa-data/data/integrated-water-availability/iwa-assessment-outputs-conus-2025/consum/consum_iwa-assessment-outputs-conus-2025_README.html
:::

---

##  {#end-break data-menu-title="# Break #" background="#047C90"}

<div class="page-center vertical-center">
<p class="custom-subtitle bottombr">{{< fa mug-hot title="a mug with steam rising out the top" >}} Take a Break</p>
<!-- <p class="caption-text">*~ This is the end of Lesson 1 (of 2) ~*</p> -->
</div>

```{r end-countdown}
countdown::countdown(
  minutes = 5,
  # left = 0, right = 0,
  # Fanfare when it's over
  play_sound = TRUE,
  color_border              = "#FFFFFF",
  color_text                = "#7aa81e",
  color_running_background  = "#7aa81e",
  color_running_text        = "#FFFFFF",
  color_finished_background = "#ffa07a",
  color_finished_text       = "#FFFFFF",
  font_size = "2em",
  )
```