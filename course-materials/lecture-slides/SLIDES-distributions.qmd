---
format: 
  revealjs:
    slide-number: true
    highlight-style: a11y
    chalkboard: true
    theme: 
      - ../../meds-slides-styles.scss
editor_options: 
  chunk_output_type: console
---

## {#title-slide data-menu-title="Title Slide" background="#053660"} 

[EDS 240: Lecture 2.2]{.custom-title}

[*Visualizing distributions*]{.custom-subtitle}

<hr class="hr-teal">

[Week 2 | January 14^th^, 2026]{.custom-subtitle3}

---

## {#what-is-dist data-menu-title="Data distribution"} 

[Visualizing data *distribution*?]{.slide-title}

<hr>

<br>
<br>

. . .

::: {.body-text-l .center-text}
Visualizing the **spread** of a numeric variable
:::

```{r dist-example}
#| eval: true
#| echo: false
#| fig-align: "center"
#| out-width: "60%"
library(palmerpenguins)
library(tidyverse)
ggplot(penguins, aes(x = flipper_length_mm)) +
  geom_histogram() +
  labs(x = "Numeric variable",
       y = "Count") +
  theme(axis.title = element_text(size = 17)) 
```

---

## {#viz-dist data-menu-title="Visualizing distributions"} 

["Core" distribution chart types]{.slide-title} 

<hr>

```{r load-pkgs}
#| eval: true
#| echo: false
library(palmerpenguins)
library(tidyverse)
library(ggridges)
library(ggbeeswarm)
```

:::: columns

::: {.column width="33%"}
::: {.center-text}
**Histograms**
:::
```{r penguin-histogram}
#| eval: true
#| echo: false
#| fig-align: "center"
ggplot(penguins, aes(x = body_mass_g, fill = species)) +
  geom_histogram(alpha = 0.5, position = "identity")
```
:::

::: {.column width="33%"}
::: {.center-text}
**Density plots**
:::
```{r penguin-density}
#| eval: true
#| echo: false
#| fig-align: "center"
ggplot(penguins, aes(x = body_mass_g, fill = species)) +
  geom_density(alpha = 0.5)
```
:::

::: {.column width="33%"}
::: {.center-text}
**Ridgeline plots**
:::
```{r penguin-ridgeline}
#| eval: true
#| echo: false
#| fig-align: "center"
ggplot(penguins, aes(x = body_mass_g, y = species, fill = species)) +
  ggridges::geom_density_ridges(alpha = 0.5)
```
:::

::::

:::: columns

::: {.column width="50%"}
::: {.center-text}
**Box plots**
:::
```{r penguin-box}
#| eval: true
#| echo: false
#| fig-align: "center"
#| out-width: "65%"
ggplot(penguins, aes(x = body_mass_g, y = species, fill = species)) +
  geom_boxplot(alpha = 0.5)
```
:::

::: {.column width="50%"}
::: {.center-text}
**Violin plots**
:::
```{r penguin-violin}
#| eval: true
#| echo: false
#| fig-align: "center"
#| out-width: "65%"
ggplot(penguins, aes(x = body_mass_g, y = species, fill = species)) +
  geom_violin(alpha = 0.5)
```
:::

::::

::: {.footer}
[Examples show the distribution of penguin body masses (g) for Adelie, Chinstrap & Gentoo penguins.]{.body-text-s .gray-text} 
:::

---

## {#mko-temps-intro data-menu-title="About the data"} 

[The data: bottom temperatures at Mohawk Reef]{.slide-title2}

<hr>

The [Santa Barbara Coastal Long Term Ecolgical Research (SBC LTER)](https://sbclter.msi.ucsb.edu/){target="_blank"} site was established in 2000 to understand the ecology of coastal kelp forest ecosystems. A number of coastal rocky reef sites are outfitted with instrumentation that collect long-term monitoring data. 

:::: {.columns}

::: {.column width="50%"}
```{r sbc-logo}
#| eval: true
#| echo: false
#| fig-align: "center"
#| out-width: "70%"
#| fig-alt: "A photo of kelp fronds rising towards the ocean's surface."
knitr::include_graphics(here::here("course-materials", "images", "lecture-slides", "sbc-logo2.png"))
```
:::

::: {.column width="50%"}
```{r kelp-pic}
#| eval: true
#| echo: false
#| fig-align: "center"
#| out-width: "100%"
#| fig-alt: "The Santa Barbara Coastal Long Term Ecological Research site's logo. A creek running down from green mountains to coastal waters meets with ocean waves. Bull kelp floats beneath the surface of the ocean."
knitr::include_graphics(here::here("course-materials", "images", "lecture-slides", "sbc-kelp.png"))
```
:::

::::

We'll be exploring **bottom temperatures recorded at Mohawk Reef**, a near-shore rocky reef and one of the Santa Barbara Coastal (SBC) LTER research sites. 

---

## {#mko-temps-wrangling data-menu-title="Wrangle data"} 

[Data wrangling]{.slide-title}

<hr>

Download data from the [EDI Data Portal](https://portal.edirepository.org/nis/mapbrowse?scope=knb-lter-sbc&identifier=2007#:~:text=Moored%20CTD%20and%20ADCP%20at%20Mohawk%20Reef%20MKO){target="_blank"} & explore the full [metadata package](https://portal.edirepository.org/nis/mapbrowse?scope=knb-lter-sbc&identifier=2007){target="_blank"} to learn more about these data.

<!-- [CODE CHUNK RENDERS BUT DOES NOT EVALUATE -- FIILEPATH REFLECTS STUDENTS CLASS REPO FILEPATH] -->

```{r example-wrangling}
#| eval: false
#| echo: true
##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
##                                    setup                                 ----
##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#..........................load packages.........................
library(tidyverse)
library(chron)
library(naniar)
library(ggridges)
library(gghighlight)
library(ggbeeswarm)
library(palmerpenguins) # for some minimal examples

#..........................import data...........................
mko <- read_csv(here::here("week2", "data", "mohawk_mooring_mko_20250117.csv"))

##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
##                                wrangle data                              ----
##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

mko_clean <- mko |>

  # keep only necessary columns ----
  select(year, month, day, decimal_time, Temp_bot, Temp_top, Temp_mid) |>

  # create datetime column (not totally necessary for our plots, but it can be helpful to know how to do this!) ----
  unite(date, year, month, day, sep = "-", remove = FALSE) |>
  mutate(time = chron::times(decimal_time)) |>
  unite(date_time, date, time, sep = " ") |>

  # coerce data types ----
  mutate(date_time = as_datetime(date_time, "%Y-%m-%d %H:%M:%S", tz = "GMT"), 
         year = as.factor(year),
         month = as.factor(month),
         day = as.numeric(day)) |>

  # add month name by indexing the built-in `month.name` vector ----
  mutate(month_name = month.name[month]) |> 

  # replace 9999s with NAs ----
  naniar::replace_with_na(replace = list(Temp_bot = 9999, 
                                         Temp_top = 9999, 
                                         Temp_mid = 9999)) |>

  # select/reorder desired columns ----
  select(date_time, year, month, day, month_name, Temp_bot, Temp_mid, Temp_top)

##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
##                            explore missing data                          ----
##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Missing data can have unexpected effects on your analyses
# It's important to explore your data for missing values so that you can decide if and how to handle them
# Data loggers can be prone to missingness (e.g. full memory, dead batteries, replacement logger)
# We can use {naniar} to explore the frequency and patterns in missing data
# Below is a short example of some naniar tools for doing so
# Check out The Missing Book (https://tmb.njtierney.com/) by Nick Tierney and Allison Horst for some great guidance

#..........counts & percentages of missing data by year..........
see_NAs <- mko_clean |> 
  group_by(year) |> 
  naniar::miss_var_summary() |>
  filter(variable == "Temp_bot")

#...................visualize missing Temp_bot...................
bottom <- mko_clean |> select(Temp_bot)
missing_temps <- naniar::vis_miss(bottom)
```

<!-- [CODE CHUNK THAT RUNS BUT DOES NOT RENDER ON SLIDE] -->

```{r actual-wrangling}
#| eval: true
#| echo: false
##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
##                                    setup                                 ----
##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#..........................load packages.........................
library(tidyverse)
library(chron)
library(naniar)
library(ggridges)
library(gghighlight)
library(ggbeeswarm)
library(see)
library(palmerpenguins) # for some minimal examples

#..........................import data...........................
mko <- read_csv(here::here("course-materials", "data", "lecture", "mohawk_mooring_mko_20250117.csv"))

##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
##                                wrangle data                              ----
##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

mko_clean <- mko |>

  # keep only necessary columns ----
  select(year, month, day, decimal_time, Temp_bot, Temp_top, Temp_mid) |>

  # create datetime column (not totally necessary for our plots, but it can be helpful to know how to do this!) ----
  unite(date, year, month, day, sep = "-", remove = FALSE) |>
  mutate(time = chron::times(decimal_time)) |>
  unite(date_time, date, time, sep = " ") |>

  # coerce data types ----
  mutate(date_time = as_datetime(date_time, "%Y-%m-%d %H:%M:%S", tz = "GMT"), 
         year = as.factor(year),
         month = as.factor(month),
         day = as.numeric(day)) |>

  # add month name by indexing the built-in `month.name` vector ----
  mutate(month_name = month.name[month]) |> 

  # replace 9999s with NAs ----
  naniar::replace_with_na(replace = list(Temp_bot = 9999, 
                                         Temp_top = 9999, 
                                         Temp_mid = 9999)) |>

  # select/reorder desired columns ----
  select(date_time, year, month, day, month_name, Temp_bot, Temp_mid, Temp_top)

##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
##                            explore missing data                          ----
##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Missing data can have unexpected effects on your analyses
# It's important to explore your data for missing values so that you can decide if and how to deal handle them
# Data loggers can be prone to missingness (e.g. full memory, dead batteries, replacement logger)
# We can use {naniar} to explore the frequency and patterns in missing data
# Below is a short example of some naniar tools for doing so
# Check out The Missing Book (https://tmb.njtierney.com/) by Nick Tierney and Allison Horst for some great guidance

#..........counts & percentages of missing data by year..........
see_NAs <- mko_clean |> 
  group_by(year) |> 
  naniar::miss_var_summary() |>
  filter(variable == "Temp_bot")

#...................visualize missing Temp_bot...................
bottom <- mko_clean |> select(Temp_bot)
missing_temps <- naniar::vis_miss(bottom)
```

```{r}
# # created / saved for lecture 4.3 ----
# ggplot(mko_clean, aes(x = Temp_bot, y = month_name, fill = after_stat(x))) +
#   ggridges::geom_density_ridges_gradient(rel_min_height = 0.01, scale = 3) +
#   geom_vline(xintercept = mean(mko_clean$Temp_bot, na.rm = TRUE), linetype = "dashed") +
#   geom_vline(xintercept = 11, linetype = "dashed", color = "darkgray") +
#   geom_vline(xintercept = 16, linetype = "dashed", color = "darkgray") +
#   geom_vline(xintercept = 21, linetype = "dashed", color = "darkgray") +
#   scale_y_discrete(limits = rev(month.name)) +
#   scale_fill_gradientn(colors = c("#2C5374","#778798", "#ADD8E6", "#EF8080", "#8B3A3A")) +
#   scale_x_continuous(breaks = seq(9, 26, by = 2)) +
#   labs(x = "Bottom Temperature (°C)",
#        title = "Bottom Temperatures at Mohawk Reef, Santa Barbara, CA",
#        subtitle = "Temperatures (°C) aggregated by month from 2005 - 2022") +
#   ggridges::theme_ridges(font_size = 13, grid = TRUE) +
#   theme(
#     plot.title.position = "plot",
#     plot.title = element_text(size = 30),
#     plot.subtitle = element_text(size = 25, margin = margin(t = 0, r = 0, b = 20, l = 0)),
#     axis.title.x = element_text(size = 23, margin = margin(t = 15, r = 0, b = 0, l = 0)),
#     axis.title.y = element_blank(),
#     axis.text = element_text(size = 20),
#     legend.position = "none",
#     panel.grid.major.x = element_blank()
#   )

# ggsave(filename = "mko_temps.png", plot = last_plot(), path = here::here("slides", "images", "week4"))
```

---

## {#histogram-density1 data-menu-title="Histogram vs. Density?"} 

[Histograms vs. Density Plots]{.slide-title}

<hr>

Both of these plots show the distribution of a numeric variable (ocean bottom temperature in °C). 

<br>

:::: {.columns}

::: {.column width="50%"}
::: {.center-text}
[**Histogram**]{.teal-text}
:::

```{r temp-histogram1}
#| eval: true
#| echo: false
#| fig-align: "center"
mko_clean |> 
  filter(month_name %in% c("April", "June", "October")) |> 
  ggplot(aes(x = Temp_bot, fill = month_name)) +
  geom_histogram(position = "identity", alpha = 0.5) +
  scale_fill_manual(values = c("#2C5374", "#ADD8E6", "#8B3A3A"))
```
:::

::: {.column width="50%"}
::: {.center-text}
[**Density plot**]{.teal-text} 
:::
```{r temp-density1}
#| eval: true
#| echo: false
#| fig-align: "right"
mko_clean |> 
  filter(month_name %in% c("April", "June", "October")) |> 
  ggplot(aes(x = Temp_bot, fill = month_name)) +
  geom_density(position = "identity", alpha = 0.5) +
  scale_fill_manual(values = c("#2C5374", "#ADD8E6", "#8B3A3A"))
```
:::
 
::::

::: {.center-text .dark-blue-text .body-text-m}
***What can you glean from each of these?***
:::

---

## {#histogram-density2 data-menu-title="Histogram vs. Density overview"} 

[Histograms vs. Density Plots]{.slide-title}

<hr>

:::: {.columns}

::: {.column width="50%"}
::: {.center-text}
[**Histogram**]{.teal-text}
:::

```{r temp-histogram2}
#| eval: true
#| echo: false
#| fig-align: "center"
mko_clean |> 
  filter(month_name %in% c("April", "June", "October")) |> 
  ggplot(aes(x = Temp_bot, fill = month_name)) +
  geom_histogram(position = "identity", alpha = 0.5) +
  scale_fill_manual(values = c("#2C5374", "#ADD8E6", "#8B3A3A"))
```

::: {.center-text}
Numeric variable is divided into several bins. The height of each bar represents the number of observations in that bin. 
::: 
:::

::: {.column width="50%"}
::: {.center-text}
[**Density plot**]{.teal-text}
:::
```{r temp-density2}
#| eval: true
#| echo: false
#| fig-align: "right"
mko_clean |> 
  filter(month_name %in% c("April", "June", "October")) |> 
  ggplot(aes(x = Temp_bot, fill = month_name)) +
  geom_density(position = "identity", alpha = 0.5) +
  scale_fill_manual(values = c("#2C5374", "#ADD8E6", "#8B3A3A"))
```

::: {.center-text}
Smoothed versions of a histogram, which use a kernel density estimate (KDE) to show the variable's probability density function. The y-axis represents the estimated density, i.e. the relative likelihood of a value occurring. The area under each curve sums to 1. 
:::
:::

::::

::: {.footer}
Check out [this cool interactive tool](https://mathisonian.github.io/kde/){target="_blank"}, by [Matthew Conlen](https://mathisonian.com/){target="_blank"}, for a visual explanation of KDE.
:::

::: {.notes}
Indicates the relative likelihood of a value occurring. 

The PDF is used to specify the probability of the random variable falling within a particular range of values, as opposed to taking on any one value <https://en.wikipedia.org/wiki/Probability_density_function>
:::

---

## {#histogram-density-distinction1 data-menu-title="Histogram vs. Density distinction 1"} 

[An important distinction]{.slide-title}

<hr>

**Histograms** show the **counts** (frequency) of values in each range (bin), represented by the height of the bars. 

. . . 

**Density plots** show the **relative proportion** of values across the range of a variable. The total area under the curve equals 1, and peaks indicate values are more concentrated. Density plots do *not* show the *absolute number* of observations. 

. . . 

<br>

We'll use some dummy data to demonstrate how this differs visually:

```{r dummy-data}
#| eval: true
#| echo: true
dummy_data <- data.frame(value = c(rnorm(n = 100, mean = 5),
                                   rnorm(n = 200, mean = 10)),
                         group = rep(c("A", "B"),
                                     times = c(100, 200)))
```

Here, we have two groups (`A`, `B`) of values which are normally distributed, but with different means. Group `A` also has a smaller sample size (100) than group `B` (200).

---

## {#histogram-density-distinction2 data-menu-title="Histogram vs. Density distinction 2"} 

[An important distinction]{.slide-title}

<hr>

:::: {.columns}

::: {.column width="50%"}

[We can see that group `B` has a larger sample size than group `A` when looking at our histogram. Additionally, we can get a good sense of our data distribution. *But* what happens when you reduce the number of `bins` (e.g. set `bins = 4`)?]{.body-text-s}

```{r dummy-hist}
#| eval: true
#| echo: true
#| fig-align: "center"
ggplot(dummy_data, aes(x = value, fill = group)) +
  geom_histogram(position = "identity", alpha = 0.7) +
  geom_rug(aes(color = group), alpha = 0.75)
```
:::

::: {.column width="50%"}

[We lose information about sample size in our density plot (note that both curves are ~the same height, despite group `B` having 2x as many observations). However, they're** great for visualizing the shape of our distributions** since they are unaffected by the number of bins.]{.body-text-s}

```{r dummy-dens}
#| eval: true
#| echo: true
#| fig-align: "center"
ggplot(dummy_data, aes(x = value, fill = group)) +
  geom_density(alpha = 0.7) +
  geom_rug(aes(color = group), alpha = 0.75)
```
:::

::::

::: {.footer}
Rug plots added as an alternative way to visualize the data distribution and also as an indicator of sample size.
:::

::: {.notes}
In the histogram, group B has higher bars; difference in height disappears in density plot
:::

---

## {#histogram-density-considerations data-menu-title="Histogram vs. Density considerations"} 

[Considerations]{.slide-title}

<hr>

Use a histogram or density plot when you want to learn about the distribution of a numeric variable that has **lots of values (observations)** with meaningful differences between those values. It's also important to keep the following considerations in mind:

:::: {.columns}

::: {.column width="50%"}

```{r histogram-considerations}
#| eval: true
#| echo: false
#| fig-align: "center"
mko_clean |> 
  filter(month_name %in% c("April", "June", "October")) |> 
  ggplot(aes(x = Temp_bot, fill = month_name)) +
  geom_histogram(position = "identity", alpha = 0.5) +
  scale_fill_manual(values = c("#2C5374", "#ADD8E6", "#8B3A3A"))
```

- [set an appropriate bin width (30 **bins** by default) based on your scale of interest]{.body-text-s}
- [too few bins (can hide important patterns, loss of distribution shape) / too many bins (adds noise and can make unimportant fluctuations appear meaningful)]{.body-text-s} 
:::

::: {.column width="50%"}

```{r density-considerations}
#| eval: true
#| echo: false
#| fig-align: "right"
mko_clean |> 
  filter(month_name %in% c("April", "June", "October")) |> 
  ggplot(aes(x = Temp_bot, fill = month_name)) +
  geom_density(position = "identity", alpha = 0.5) +
  scale_fill_manual(values = c("#2C5374", "#ADD8E6", "#8B3A3A"))
```

- [useful when you want to visualize the shape of your data (not affected by bin number)]{.body-text-s}
- [does not indicate sample size (and can be misleading with small data sets)]{.body-text-s}
- [band width affects level of smoothing]{.body-text-s}
:::

::::

---

## {#histogram-density-groupnum data-menu-title="Too many groups"} 

[Avoid plotting too many groups at once]{.slide-title}

<hr>

Histogram & density plots don't work great when you have too many groups to plot at once. Twelve groups (`month_name`) is too many, especially when the range of temperature values for each of our groups largely overlap:

:::: {.columns}

::: {.column width="50%"}

```{r histogram-crowding}
#| eval: true
#| echo: true
#| out-width: "100%"
#| fig-align: "center"
mko_clean |> 
  mutate(month_name = factor(month_name, levels = month.name)) |> 
  ggplot(aes(x = Temp_bot, fill = month_name)) +
  geom_histogram(position = "identity", alpha = 0.5)
```
:::

::: {.column width="50%"}
```{r density-crowding}
#| eval: true
#| echo: true
#| out-width: "90%"
#| fig-align: "center"
mko_clean |> 
  mutate(month_name = factor(x = month_name, levels = month.name)) |> 
  ggplot(aes(x = Temp_bot, fill = month_name)) +
  geom_density(alpha = 0.5)
```
:::

::::

---

## {#small-multiples data-menu-title="Fixes - small multiples"} 

[Consider faceting (small multiples)]{.slide-title}

<hr>

If you want to plot all groups, consider splitting them into small multiples. If so, does color add any valuable information? Remove if not:

:::: {.columns}

::: {.column width="50%"}

```{r histogram-facets}
#| eval: true
#| echo: true
#| out-width: "100%"
#| fig-align: "center"
#| code-line-numbers: "3,5"
mko_clean |> 
  mutate(month_name = factor(month_name, levels = month.name)) |> 
  ggplot(aes(x = Temp_bot)) +
  geom_histogram() +
  facet_wrap(~month_name)
```
:::

::: {.column width="50%"}
```{r density-facets}
#| eval: true
#| echo: true
#| out-width: "90%"
#| fig-align: "center"
#| code-line-numbers: "3,5"
mko_clean |> 
  mutate(month_name = factor(month_name, levels = month.name)) |> 
  ggplot(aes(x = Temp_bot)) +
  geom_density(fill = "gray30") +
  facet_wrap(~month_name)
```
:::

::::

---

## {#fewer-groups data-menu-title="Fixes - plot fewer groups"} 

[Consider plotting fewer groups]{.slide-title}

<hr>

[Do you *need* all (12) groups, or can you share the most relevant data using fewer groups? Let's compare just three months: April (generally the coldest month), October (generally a hot month), and June (somewhere in between):]{.body-text-s}

:::: {.columns}

::: {.column width="50%"}

```{r histogram-filtered}
#| eval: true
#| echo: true
#| out-width: "100%"
#| fig-align: "center"
#| code-line-numbers: "3-6"
mko_clean |> 
  mutate(month_name = factor(month_name, levels = month.name)) |> 
  filter(month_name %in% c("April", "June", "October")) |> 
  ggplot(aes(x = Temp_bot, fill = month_name)) + 
  geom_histogram(position = "identity", alpha = 0.5,  color = "black") +
  scale_fill_manual(values = c("#2C5374", "#ADD8E6", "#8B3A3A"))
```
:::

::: {.column width="50%"}
```{r density-filtered}
#| eval: true
#| echo: true
#| out-width: "90%"
#| fig-align: "center"
#| code-line-numbers: "2-5"
mko_clean |> 
  filter(month_name %in% c("April", "June", "October")) |> 
  ggplot(aes(x = Temp_bot, fill = month_name)) +
  geom_density(alpha = 0.5) + 
  scale_fill_manual(values = c("#2C5374", "#ADD8E6", "#8B3A3A"))
```

::: {.center-text .dark-blue-text .body-text-s}
***Why are the months still in chronological order, despite not reordering them using `mutate()`, as we do for our histogram?***
:::
:::

::::

---

## {#modify-binbandwidths data-menu-title="Modify bin widths"} 

[Modify bin / bandwidths]{.slide-title}

<hr>

:::: {.columns}

::: {.column width="50%"}

[Modify `binwidth` (30 `bins` by default) – does a bin width of 1 (degree Celsius) actually make sense? Consider scale of interest. Also be mindful when using bins – too few bins will result in loss of distribution shape.]{.body-text-s}

```{r histogram-bins}
#| eval: true
#| echo: true
#| out-width: "80%"
#| fig-align: "center"
#| code-line-numbers: "5"
mko_clean |> 
  filter(month_name %in% c("April", "June", "October")) |> 
  mutate(month_name = factor(month_name, levels = month.name)) |> 
  ggplot(aes(x = Temp_bot, fill = month_name)) +
  geom_histogram(position = "identity", alpha = 0.5, binwidth = 1) +
  scale_fill_manual(values = c("#2C5374", "#ADD8E6", "#8B3A3A"))
```
:::

::: {.column width="50%"}

[Modify bandwidth by declaring a multiplier of the default bandwidth adjustment (default `adjust = 1`). A small bandwidth leads to undersmoothing, a large bandwidth leads to oversmoothing. Goal: accurately visualize the true underlying data distribution shape while reducing noise:]{.body-text-s}

```{r density-bands}
#| eval: true
#| echo: true
#| out-width: "80%"
#| fig-align: "center"
#| code-line-numbers: "4"
mko_clean |> 
  filter(month_name %in% c("April", "June", "October")) |> 
  ggplot(aes(x = Temp_bot, fill = month_name)) +
  geom_density(alpha = 0.5, adjust = 0.5) + 
  scale_fill_manual(values = c("#2C5374", "#ADD8E6", "#8B3A3A"))
```
:::

::::

::: {.footer}
`geom_density()` relies on `density()`, which uses the `nrd0` bandwidth selector (Silverman's rule-of-thumb-style estimator). This is a reliable starting point, but you may consider other selectors based on your data. Check out [thius article](https://aakinshin.net/posts/kde-bw/) to read more about bandwidth selection.
:::

::: {.notes}
Bandwidth is a parameter that controls the level of smoothing. Smaller bandwidths result in a more detailed (but potentially noisy) curve, while larger bandwidths create a smoother curve by averaging more of the data.

Default value: adjust = 1. This uses the default bandwidth provided by the underlying density estimation method.
:::

---

## {#density-hist-combo data-menu-title="Density / Histogram combo"} 

[Overlay histogram & density plots as a sanity check]{.slide-title3}

<hr>

[Overlay histogram and density plots to check that smoothing assumptions of the density curve align with the actual data distribution. This requires rescaling the histogram to match the density curve scale. Adding `y = after_stat(density)` within the `aes()` function rescales the histogram counts so that bar areas integrate to 1:]{.body-text-s}

```{r histogram-density-combo}
#| eval: true
#| echo: true
#| fig-align: "center"
ggplot(mko_clean, aes(x = Temp_bot, y = after_stat(density))) + # scale down hist to match density curve
  geom_histogram(fill = "gray", color = "black", alpha = 0.75) +
  geom_density(linewidth = 1) 
```

::: {.center-text .dark-blue-text}
***What should you carefully consider when checking the smoothing asumptions of your density curve against a histogram?*** 
:::

::: {.footer}
Check out this [great blog post](https://yjunechoe.github.io/posts/2022-03-10-ggplot2-delayed-aes-1/){target="_blank"} on the `after_stat()` function, by [June Choe](https://yjunechoe.github.io/index.html){target="_blank"}
:::

::: {.notes}
Answer: histograms also require choosing an appropriate bin `width` -- a poorly chosen bin `width` can mislead in the same way that a poorly chosen bandwidth can!

- `after_stat(density)` tells ggplot to use the computed *density* stat for the `y` aesthetic
- by default, a histogram computes *counts/frequency* for the bins, but with `after_stat(density)`, y values for the histogram bins will represent the density rather than counts
- `after_stat()` needs to be used to delay the computation of this y-axis aesthetic until after ggplot executes the `geom_histogram()` layer (which occurs second, after aesthetic mappings inside `ggplot()`)

See <https://stackoverflow.com/questions/46734555/ggplot2-histogram-why-do-y-density-and-stat-density-differ>

**Insights:**

- The density curve can help identify patterns that might be harder to see in the histogram due to bin size or alignment.
- If the bins are too wide, important details in the data distribution might be missed in the histogram, but the density curve can reveal them.
- Conversely, if the curve is overly smoothed (due to a large adjust), it might miss sharp features present in the histogram.
:::

<!-- ---

## {#scaled-density data-menu-title="Scaled density"} 

[Use scaled density plots for comparing groups to a whole]{.slide-title3}

<hr>

[In a normal density plot, the area under the curve(s) is equal to 1. **In a scaled density plot, the area under the curve reflects the number of observations for each group.**]{.body-text-s}

[We can use scaled density plots to compare individual group distributions to the total distribution. Demonstrated here, using the `penguins` data set:]{.body-text-s}

```{r load-palmerpenguins}
#| eval: true
#| echo: false
library(palmerpenguins)
```

```{r scaled-density}
#| eval: true
#| echo: true
#| out-width: "100%"
#| output-location: column
# use `after_stat(count)` to plot density of observations ----
ggplot(penguins, aes(x = body_mass_g, y = after_stat(count))) +
 
  # plot full distribution curve with label "all penguins"; remove 'species' col so that this doesn't get faceted later on ----
  geom_density(data = select(penguins, -species), 
               aes(fill = "all penguins"), color = "transparent") +
  
  # plot second curve with label "species" ----
  geom_density(aes(fill = "species"), color = "transparent") +
  
  # facet wrap by species ----
  facet_wrap(~species, nrow = 1) +
  
  # update colors, x-axis label, legend position ----
  scale_fill_manual(values = c("grey","green4"), name = NULL) +
  labs(x = "Body Mass (g)") +
  theme(legend.position = "top")
```

::: {.footer}
Example adapted from [Meghan Hall](https://meghan.rbind.io/){target="_blank"}'s CMU 36-315 [Lecture 7](https://cmu-36315.netlify.app/slides/36-315_summer2021_lec7#75){target="_blank"}. For more on scaled density plots, check out [this post](https://datawookie.dev/blog/2022/10/scaling-density-plots/){target="_blank"}, by [Andrew Collier](https://github.com/datawookie){target="_blank"}.
::: -->

---

## {#many-group-options data-menu-title="What if we have many groups?"} 

[If you have multiple to many groups, consider these alternatives:]{.slide-title2}

<hr>

Ridgeline plots, box plots, and violin plots are better suited for visualizing the distribution of a numeric variable with many (e.g. >3) groups.

:::: {.columns}

::: {.column width="33%"}

::: {.center-text .teal-text}
**Ridgeline plot**
:::

```{r alt-ridgeline}
#| eval: true
#| echo: false
#| fig-align: "center"
ggplot(mko_clean, aes(x = Temp_bot, y = month_name, fill = after_stat(x))) +
  ggridges::geom_density_ridges_gradient(rel_min_height = 0.01, scale = 3) +
  scale_y_discrete(limits = rev(month.name)) +
  scale_fill_gradientn(colors = c("#2C5374","#849BB4", "#D9E7EC", "#EF8080", "#8B3A3A"))
```
:::

::: {.column width="33%"}

::: {.center-text .teal-text}
**Box plot**
:::

```{r alt-boxplot}
#| eval: true
#| echo: false
#| fig-align: "center"
ggplot(mko_clean, aes(x = month_name, y = Temp_bot)) +
  geom_boxplot() +
  scale_x_discrete(limits = rev(month.name)) +
  coord_flip()
```
:::

::: {.column width="33%"}

::: {.center-text .teal-text}
**Violin plot**
:::

```{r alt-violin}
#| eval: true
#| echo: false
#| fig-align: "center"
ggplot(mko_clean, aes(x = month_name, y = Temp_bot)) +
  geom_violin() +
  scale_x_discrete(limits = rev(month.name)) +
  coord_flip()
```
:::

::::

**Appropriately ordering groups is important for improving readability.** If a natural order exists (e.g. months of the year), use it. If not, order groups by a meaningful summary statistic, such as the median (e.g. ordering penguin species by median body weight).

. . . 

<br>

::: {.center-text .body-text-m .teal-text}
**Let's build them!**
:::

---

## {#ggridges data-menu-title="{ggridges}"} 

[Ridegeline plots for comparing distribution *shapes* across *many ordered groups*]{.slide-title3}

<hr>

[Ridgeline plots are most effective when groups have a meaningful order, such as an inherent ranking, or when you want to visualize how distributions change over time (e.g. months, years) or space (e.g. longitude, elevation). The [`{ggridges}` package](https://wilkelab.org/ggridges/){target="_blank"} has various geoms for creating ridgeline plots, including:]{.body-text-s} 

:::: {.columns}

::: {.column width="50%"}
::: {.center-text .body-text-s}
`geom_density_ridges()`:
:::
```{r basic-ridgeline}
#| eval: true
#| echo: true
#| fig-align: "center"
mko_clean |> 
  mutate(month_name = factor(month_name, levels = rev(month.name))) |> # alt, within ggplot: `scale_y_discrete(limits = rev(month.name))`
  ggplot(aes(x = Temp_bot, y = month_name)) +
  ggridges::geom_density_ridges(rel_min_height = 0.01, scale = 3)  # `rel_min_height` sets threshold for relative height of density curves (any values below threshold treated as 0); `scale` controls extent to which different densities overlap
```
:::

::: {.column width="50%"}
::: {.center-text .body-text-s}
`geom_density_ridges_gradient()`:
:::
```{r gradient-ridgeline}
#| eval: true
#| echo: true
#| fig-align: "center"
mko_clean |> 
  mutate(month_name = factor(month_name, levels = rev(month.name))) |> # alt, within ggplot: `scale_y_discrete(limits = rev(month.name))`
  ggplot(aes(x = Temp_bot, y = month_name, fill = after_stat(x))) + # `fill = after_stat(x)` tells ggplot to compute the `x` values (representing `Temp_bot`) after the statistical transformation (density estimation) and map those computed `x` values to the `fill` aesthetic. As a result, the gradient fill of each density curve will reflect the temperature values along the x-axis.
  ggridges::geom_density_ridges_gradient(rel_min_height = 0.01, scale = 3) + # `rel_min_height` sets threshold for relative height of density curves (any values below threshold treated as 0); `scale` controls extent to which different densities overlap
  scale_fill_gradientn(colors = c("#2C5374","#849BB4", "#D9E7EC", "#EF8080", "#8B3A3A"))
```
:::

::::

::: {.notes}
Ridgeline plots work well when there is a clear pattern in the result (e.g. if there is an obvious ranking in groups) and / or when visualizing changes in distributions over time or space
:::

<!-- ---

## {#ggridges-jitter data-menu-title="{ggridges} jitter"} 

[Add raw data to your ridgeline plot]{.slide-title}

<hr>

[Ridgeline plots emphasize the shape of distributions rather than the number of observations (just like density plots). Adding jittered raw data points can provide context when sample sizes are small enough to remain readable. Our temperature data are too dense for this (points would overlap heavily), so we’ll demo using `{palmerpenguins}`:]{.body-text-s}

:::: {.columns}

::: {.column width="50%"}
::: {.center-text .gray-text .body-text-s}
Jittered data points
:::
```{r ridgeline-jitter}
#| eval: true
#| echo: true
#| fig-align: "center"
penguins |> 
  mutate(species = fct_reorder(species, body_mass_g, .fun = mean)) |> 
  ggplot(aes(x = body_mass_g, y = species)) +
  ggridges::geom_density_ridges(jittered_points = TRUE, 
                                alpha = 0.5, point_size = 0.5)
```
:::

::: {.column width="50%"}
::: {.center-text .gray-text .body-text-s}
Raincloud plot
:::
```{r ridgeline-raincloud}
#| eval: true
#| echo: true
#| fig-align: "center"
penguins |> 
  mutate(species = fct_reorder(species, body_mass_g, .fun = mean)) |> 
  ggplot(aes(x = body_mass_g, y = species)) +
  ggridges::geom_density_ridges(jittered_points = TRUE, alpha = 0.5, 
                                point_size = 0.5, scale = 0.6,
                                position = "raincloud")
```
:::

:::: -->

---

## {#boxplot-overview1 data-menu-title="Box plot overview 1"} 

[Box plots for comparing distribution summaries across multiple groups]{.slide-title3}

<hr>

[Box plots *summarize* data, meaning they don't show the underlying shape of the distribution or sample size (though jittered points can be added, if appropriate). They provide a compact summary of a dataset's center, spread and indications of skewness, and allow many groups to be compared side-by-side while remaining readable.]{.body-text-s}

<br>

```{r boxplot-anatomy}
#| eval: true
#| echo: false
#| out-width: "100%"
#| fig-align: "center"
knitr::include_graphics(here::here("course-materials", "images", "lecture-slides", "boxplot.png"))
```

---

## {#boxplot-overview2 data-menu-title="Box plot overview 2"} 

[Box plots for comparing distribution summaries across multiple groups]{.slide-title3}

<hr>

[Box plots *summarize* data, meaning they don't show the underlying shape of the distribution or sample size (though jittered points can be added, if appropriate). They provide a compact summary of a dataset's center, spread and indications of skewness, and allow many groups to be compared side-by-side while remaining readable.]{.body-text-s}

<br>

```{r boxplot-hist-comparison}
#| eval: true
#| echo: false
#| out-width: "100%"
#| fig-align: "center"
knitr::include_graphics(here::here("course-materials", "images", "lecture-slides", "boxplot-quartiles.png"))
```

::: {.footer}
Image source: [A complete guid to box plots](https://www.atlassian.com/data/charts/box-plot-complete-guide){target="_blank"}, by Mike Yi (Atlassian)
:::

---

## {#temp-boxplot data-menu-title="Temp box plot"} 

[Box plots for comparing distribution *summaries* across groups]{.slide-title3}

<hr>

If your x-axis text is long, consider flipping your axes to make them less crunched:

```{r basic-boxplot}
#| eval: true
#| echo: true
#| fig-align: "center"
ggplot(mko_clean, aes(x = month_name, y = Temp_bot)) +
  geom_boxplot() +
  scale_x_discrete(limits = rev(month.name)) + # an alt way to reorder groups within ggplot, rather than during data wrangling
  coord_flip()
```

::: {.center-text .dark-blue-text}
***What are the tradeoffs between reordering groups within a ggplot (as above) vs. during the data wrangling stage (e.g. as we did for our [histogram and density](distributions-slides.qmd#histogram-density-groupnum) and [ridgeline plots](distributions-slides.qmd#ggridges))?***
:::

---

## {#highlight data-menu-title="Highlight group(s) of interest"} 

[Highlight group(s) of interest to focus attention]{.slide-title}

<hr>

The [`{gghighlight}` package](https://yutannihilation.github.io/gghighlight/index.html){target="_blank"} makes this super easy:

```{r boxplot-gghighlight}
#| eval: true
#| echo: true
#| fig-align: "center"
ggplot(mko_clean, aes(x = month_name, y = Temp_bot, fill = month_name)) +
  geom_boxplot() +
  scale_x_discrete(limits = rev(month.name)) +
  gghighlight::gghighlight(month_name == "October") +
  coord_flip() +
  theme(legend.position = "none")
```

---

## {#boxplot-jitter data-menu-title="Box plot + jittered data"} 

[Overlay jittered data, if appropriate]{.slide-title}

<hr>

Since box plots hide sample size, consider overlaying raw data points using `geom_jitter()`. It's important that you **remove outliers**, since overlaying raw data means those data points will be plotted a second time. 

:::: {.columns}

::: {.column width="50%"}
::: {.center-text .body-text-s}
Overlaying raw data does **not** work when you have many observations:
:::

```{r jittered-boxplot-temps}
#| eval: true
#| echo: true
#| fig-align: "center"
ggplot(mko_clean, aes(x = month_name, y = Temp_bot)) +
  geom_boxplot(outlier.shape = NA) + # remember to remove outliers!
  geom_jitter(alpha = 0.5, width = 0.2) +
  scale_x_discrete(limits = rev(month.name)) + # an alt way to reorder groups within ggplot, rather than during data wrangling
  coord_flip()
```
:::

::: {.column width="50%"}
::: {.center-text .body-text-s}
But it's a great option for datasets with fewer observations:
:::

```{r jittered-boxplot-penguins}
#| eval: true
#| echo: true
#| fig-align: "center"
ggplot(penguins, aes(x = species, y = body_mass_g)) +
  geom_boxplot(outlier.shape = NA) + # remember to remove outliers!
  geom_jitter(alpha = 0.5, width = 0.2) 
```

:::

::::

---

## {#boxplot-beeswarm data-menu-title="Beeswarm"} 

[Beeswarm plots as an alternative]{.slide-title}

<hr>

[Similar to overlaying raw jittered data points, we can combine our box plot with a beeswarm plot using the [`{ggbeeswarm}` package](https://github.com/eclarke/ggbeeswarm){target="_blank"}. Beeswarm plots visualize the density of data at each point, as well as arrange points that would normally overlap so that they fall next to one another instead. Consider using a standalone beeswarm plot here as well! We’ll again use the `penguins` data set to demo:]{.body-text-s}

```{r beeswarm}
#| eval: true
#| echo: true
#| fig-align: "center"
ggplot(penguins, aes(x = species, y = body_mass_g)) +
  geom_boxplot(outlier.shape = NA) + # remember to remove outliers!
  ggbeeswarm::geom_beeswarm(size = 1) 
```

---

## {#boxplot-dodge data-menu-title="Dodging"} 

[Dodge when you have an additional grouping variable]{.slide-title2}

<hr>

[You may have data where you want to include an additional grouping variable -- for example, let's say we want to plot penguin body masses by species *and* year. We'll need to at least `dodge` our overlaid points so that they sit on top of the correct box. Preferably, we both `jitter` *and* `dodge` our points:]{.body-text-s}

```{r boxplot-dodge}
#| eval: true
#| echo: true
#| fig-align: "center"
ggplot(penguins, aes(x = species, y = body_mass_g, color = as.factor(year))) +
  geom_boxplot(outlier.shape = NA) + # remember to remove outliers!
  geom_point(alpha = 0.5, 
             position = position_jitterdodge(jitter.width = 0.2))
```

---

## {#violin-plot data-menu-title="Violin plot"} 

[Violin plots for comparing distribution *shapes* across multiple groups]{.slide-title2}

<hr>

Violin plots show the *shape* of a distribution by visualizing the kernel density estimate (KDE) of a variable (i.e. ranges with more data points appear wider). They're similar to density plots, but make it much easier to compare distribution shapes across multiple groups. 

```{r violin-example}
#| eval: true
#| echo: false
#| out-width: "80%"
#| fig-align: "center"
knitr::include_graphics(here::here("course-materials", "images", "lecture-slides", "violin-examples.png"))
```

::: {.footer}
Image source: [A complete guide to violin plots](https://www.atlassian.com/data/charts/violin-plot-complete-guide){target="_blank"}, by Mike Yi (Atlassian)
:::

---

## {#violin-histogram data-menu-title="Violin + histogram"} 

[Overlay your violin plot with other geoms to add context]{.slide-title2}

<hr>

[Be sure to order your groups appropriately (e.g. by natural order, or by median value) and consider overlaying another chart type (e.g. box plot for many data points, rug or beeswarm for low-medium number of data points) for additional context. Rotate your axes if your x-axis text is long:]{.body-text-s}

```{r violin-boxplot}
#| eval: true
#| echo: true
#| out-width: "50%"
#| fig-align: "center"
ggplot(mko_clean, aes(x = month_name, y = Temp_bot)) +
  geom_violin() +
  geom_boxplot(width = 0.1, fill = "gray", color = "gray30", alpha = 0.5) +
  scale_x_discrete(limits = rev(month.name)) +
  coord_flip()
```

<!-- --- -->

<!-- ## {#going-further data-menu-title="Going further"}  -->

<!-- [Check out the `{ggdist}` package!]{.slide-title} -->

<!-- <hr> -->

<!-- The [`{ggdist}` package](https://mjskay.github.io/ggdist/) provides some additional geoms and stats for visualizing distributions and uncertainty. Check it out! -->

<!-- ```{r} -->
<!-- #| eval: true -->
<!-- #| echo: false -->
<!-- #| fig-align: "center" -->
<!-- #| out-width: "100%" -->
<!-- knitr::include_graphics("images/week2/ggdist.png") -->
<!-- ``` -->

---

##  {#end-break data-menu-title="# End / Break #" background="#047C90"}

<div class="page-center vertical-center">
<p class="custom-subtitle bottombr">{{< fa mug-hot title="a mug with steam rising out the top" >}} Take a Break</p>
<!-- <p class="caption-text">*~ This is the end of Lesson 2 (of 3) ~*</p> -->
</div>

```{r}
countdown::countdown(
  minutes = 5,
  # left = 0, right = 0,
  # Fanfare when it's over
  play_sound = TRUE,
  color_border              = "#FFFFFF",
  color_text                = "#7aa81e",
  color_running_background  = "#7aa81e",
  color_running_text        = "#FFFFFF",
  color_finished_background = "#ffa07a",
  color_finished_text       = "#FFFFFF",
  font_size = "2em",
  )
```

